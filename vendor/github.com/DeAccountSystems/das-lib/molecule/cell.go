// Generated by Molecule 0.7.2
// Generated by Moleculec-Go 0.1.8

package molecule

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type ActionDataBuilder struct {
	action Bytes
	params Bytes
}

func (s *ActionDataBuilder) Build() ActionData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.params.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.action.AsSlice())
	b.Write(s.params.AsSlice())
	return ActionData{inner: b.Bytes()}
}

func (s *ActionDataBuilder) Action(v Bytes) *ActionDataBuilder {
	s.action = v
	return s
}

func (s *ActionDataBuilder) Params(v Bytes) *ActionDataBuilder {
	s.params = v
	return s
}

func NewActionDataBuilder() *ActionDataBuilder {
	return &ActionDataBuilder{action: BytesDefault(), params: BytesDefault()}
}

type ActionData struct {
	inner []byte
}

func ActionDataFromSliceUnchecked(slice []byte) *ActionData {
	return &ActionData{inner: slice}
}
func (s *ActionData) AsSlice() []byte {
	return s.inner
}

func ActionDataDefault() ActionData {
	return *ActionDataFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ActionDataFromSlice(slice []byte, compatible bool) (*ActionData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &ActionData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ActionData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &ActionData{inner: slice}, nil
}

func (s *ActionData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ActionData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ActionData) Len() uint {
	return s.FieldCount()
}
func (s *ActionData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ActionData) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *ActionData) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *ActionData) Action() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ActionData) Params() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ActionData) AsBuilder() ActionDataBuilder {
	ret := NewActionDataBuilder().Action(*s.Action()).Params(*s.Params())
	return *ret
}

type ConfigCellMainBuilder struct {
	status                   Uint8
	type_id_table            TypeIdTable
	das_lock_out_point_table DasLockOutPointTable
}

func (s *ConfigCellMainBuilder) Build() ConfigCellMain {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMain{inner: b.Bytes()}
}

func (s *ConfigCellMainBuilder) Status(v Uint8) *ConfigCellMainBuilder {
	s.status = v
	return s
}

func (s *ConfigCellMainBuilder) TypeIdTable(v TypeIdTable) *ConfigCellMainBuilder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainBuilder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainBuilder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainBuilder() *ConfigCellMainBuilder {
	return &ConfigCellMainBuilder{status: Uint8Default(), type_id_table: TypeIdTableDefault(), das_lock_out_point_table: DasLockOutPointTableDefault()}
}

type ConfigCellMain struct {
	inner []byte
}

func ConfigCellMainFromSliceUnchecked(slice []byte) *ConfigCellMain {
	return &ConfigCellMain{inner: slice}
}
func (s *ConfigCellMain) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainDefault() ConfigCellMain {
	return *ConfigCellMainFromSliceUnchecked([]byte{73, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 125, 1, 0, 0, 0, 108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainFromSlice(slice []byte, compatible bool) (*ConfigCellMain, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ConfigCellMain{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMain", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMain{inner: slice}, nil
}

func (s *ConfigCellMain) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMain) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMain) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMain) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMain) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMain) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMain) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMain) TypeIdTable() *TypeIdTable {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableFromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMain) DasLockOutPointTable() *DasLockOutPointTable {
	var ret *DasLockOutPointTable
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMain) AsBuilder() ConfigCellMainBuilder {
	ret := NewConfigCellMainBuilder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableBuilder struct {
	account_cell         Hash
	apply_register_cell  Hash
	balance_cell         Hash
	income_cell          Hash
	pre_account_cell     Hash
	proposal_cell        Hash
	account_sale_cell    Hash
	account_auction_cell Hash
	offer_cell           Hash
	reverse_record_cell  Hash
}

func (s *TypeIdTableBuilder) Build() TypeIdTable {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (10 + 1)
	offsets := make([]uint32, 0, 10)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_auction_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.reverse_record_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.account_sale_cell.AsSlice())
	b.Write(s.account_auction_cell.AsSlice())
	b.Write(s.offer_cell.AsSlice())
	b.Write(s.reverse_record_cell.AsSlice())
	return TypeIdTable{inner: b.Bytes()}
}

func (s *TypeIdTableBuilder) AccountCell(v Hash) *TypeIdTableBuilder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableBuilder) ApplyRegisterCell(v Hash) *TypeIdTableBuilder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableBuilder) BalanceCell(v Hash) *TypeIdTableBuilder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableBuilder) IncomeCell(v Hash) *TypeIdTableBuilder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableBuilder) PreAccountCell(v Hash) *TypeIdTableBuilder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableBuilder) ProposalCell(v Hash) *TypeIdTableBuilder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableBuilder) AccountSaleCell(v Hash) *TypeIdTableBuilder {
	s.account_sale_cell = v
	return s
}

func (s *TypeIdTableBuilder) AccountAuctionCell(v Hash) *TypeIdTableBuilder {
	s.account_auction_cell = v
	return s
}

func (s *TypeIdTableBuilder) OfferCell(v Hash) *TypeIdTableBuilder {
	s.offer_cell = v
	return s
}

func (s *TypeIdTableBuilder) ReverseRecordCell(v Hash) *TypeIdTableBuilder {
	s.reverse_record_cell = v
	return s
}

func NewTypeIdTableBuilder() *TypeIdTableBuilder {
	return &TypeIdTableBuilder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), account_sale_cell: HashDefault(), account_auction_cell: HashDefault(), offer_cell: HashDefault(), reverse_record_cell: HashDefault()}
}

type TypeIdTable struct {
	inner []byte
}

func TypeIdTableFromSliceUnchecked(slice []byte) *TypeIdTable {
	return &TypeIdTable{inner: slice}
}
func (s *TypeIdTable) AsSlice() []byte {
	return s.inner
}

func TypeIdTableDefault() TypeIdTable {
	return *TypeIdTableFromSliceUnchecked([]byte{108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableFromSlice(slice []byte, compatible bool) (*TypeIdTable, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 10 == 0 {
		return &TypeIdTable{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTable", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 10 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 10 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTable{inner: slice}, nil
}

func (s *TypeIdTable) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTable) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTable) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTable) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTable) CountExtraFields() uint {
	return s.FieldCount() - 10
}

func (s *TypeIdTable) HasExtraFields() bool {
	return 10 != s.FieldCount()
}

func (s *TypeIdTable) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) ProposalCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) AccountSaleCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) AccountAuctionCell() *Hash {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) OfferCell() *Hash {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) ReverseRecordCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[40:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[44:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTable) AsBuilder() TypeIdTableBuilder {
	ret := NewTypeIdTableBuilder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell())
	return *ret
}

type DasLockOutPointTableBuilder struct {
	ckb_signall        OutPoint
	ckb_multisign      OutPoint
	ckb_anyone_can_pay OutPoint
	eth                OutPoint
	tron               OutPoint
}

func (s *DasLockOutPointTableBuilder) Build() DasLockOutPointTable {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_signall.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_multisign.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_anyone_can_pay.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.eth.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tron.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ckb_signall.AsSlice())
	b.Write(s.ckb_multisign.AsSlice())
	b.Write(s.ckb_anyone_can_pay.AsSlice())
	b.Write(s.eth.AsSlice())
	b.Write(s.tron.AsSlice())
	return DasLockOutPointTable{inner: b.Bytes()}
}

func (s *DasLockOutPointTableBuilder) CkbSignall(v OutPoint) *DasLockOutPointTableBuilder {
	s.ckb_signall = v
	return s
}

func (s *DasLockOutPointTableBuilder) CkbMultisign(v OutPoint) *DasLockOutPointTableBuilder {
	s.ckb_multisign = v
	return s
}

func (s *DasLockOutPointTableBuilder) CkbAnyoneCanPay(v OutPoint) *DasLockOutPointTableBuilder {
	s.ckb_anyone_can_pay = v
	return s
}

func (s *DasLockOutPointTableBuilder) Eth(v OutPoint) *DasLockOutPointTableBuilder {
	s.eth = v
	return s
}

func (s *DasLockOutPointTableBuilder) Tron(v OutPoint) *DasLockOutPointTableBuilder {
	s.tron = v
	return s
}

func NewDasLockOutPointTableBuilder() *DasLockOutPointTableBuilder {
	return &DasLockOutPointTableBuilder{ckb_signall: OutPointDefault(), ckb_multisign: OutPointDefault(), ckb_anyone_can_pay: OutPointDefault(), eth: OutPointDefault(), tron: OutPointDefault()}
}

type DasLockOutPointTable struct {
	inner []byte
}

func DasLockOutPointTableFromSliceUnchecked(slice []byte) *DasLockOutPointTable {
	return &DasLockOutPointTable{inner: slice}
}
func (s *DasLockOutPointTable) AsSlice() []byte {
	return s.inner
}

func DasLockOutPointTableDefault() DasLockOutPointTable {
	return *DasLockOutPointTableFromSliceUnchecked([]byte{204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DasLockOutPointTableFromSlice(slice []byte, compatible bool) (*DasLockOutPointTable, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &DasLockOutPointTable{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DasLockOutPointTable", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = OutPointFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &DasLockOutPointTable{inner: slice}, nil
}

func (s *DasLockOutPointTable) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DasLockOutPointTable) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DasLockOutPointTable) Len() uint {
	return s.FieldCount()
}
func (s *DasLockOutPointTable) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DasLockOutPointTable) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *DasLockOutPointTable) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *DasLockOutPointTable) CkbSignall() *OutPoint {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTable) CkbMultisign() *OutPoint {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTable) CkbAnyoneCanPay() *OutPoint {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTable) Eth() *OutPoint {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTable) Tron() *OutPoint {
	var ret *OutPoint
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = OutPointFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = OutPointFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DasLockOutPointTable) AsBuilder() DasLockOutPointTableBuilder {
	ret := NewDasLockOutPointTableBuilder().CkbSignall(*s.CkbSignall()).CkbMultisign(*s.CkbMultisign()).CkbAnyoneCanPay(*s.CkbAnyoneCanPay()).Eth(*s.Eth()).Tron(*s.Tron())
	return *ret
}

type ConfigCellAccountBuilder struct {
	max_length                Uint32
	basic_capacity            Uint64
	prepared_fee_capacity     Uint64
	expiration_grace_period   Uint32
	record_min_ttl            Uint32
	record_size_limit         Uint32
	transfer_account_fee      Uint64
	edit_manager_fee          Uint64
	edit_records_fee          Uint64
	common_fee                Uint64
	transfer_account_throttle Uint32
	edit_manager_throttle     Uint32
	edit_records_throttle     Uint32
	common_throttle           Uint32
}

func (s *ConfigCellAccountBuilder) Build() ConfigCellAccount {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (14 + 1)
	offsets := make([]uint32, 0, 14)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.max_length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.expiration_grace_period.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_min_ttl.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_size_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.transfer_account_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_manager_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_records_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.common_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.transfer_account_throttle.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_manager_throttle.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_records_throttle.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.common_throttle.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.max_length.AsSlice())
	b.Write(s.basic_capacity.AsSlice())
	b.Write(s.prepared_fee_capacity.AsSlice())
	b.Write(s.expiration_grace_period.AsSlice())
	b.Write(s.record_min_ttl.AsSlice())
	b.Write(s.record_size_limit.AsSlice())
	b.Write(s.transfer_account_fee.AsSlice())
	b.Write(s.edit_manager_fee.AsSlice())
	b.Write(s.edit_records_fee.AsSlice())
	b.Write(s.common_fee.AsSlice())
	b.Write(s.transfer_account_throttle.AsSlice())
	b.Write(s.edit_manager_throttle.AsSlice())
	b.Write(s.edit_records_throttle.AsSlice())
	b.Write(s.common_throttle.AsSlice())
	return ConfigCellAccount{inner: b.Bytes()}
}

func (s *ConfigCellAccountBuilder) MaxLength(v Uint32) *ConfigCellAccountBuilder {
	s.max_length = v
	return s
}

func (s *ConfigCellAccountBuilder) BasicCapacity(v Uint64) *ConfigCellAccountBuilder {
	s.basic_capacity = v
	return s
}

func (s *ConfigCellAccountBuilder) PreparedFeeCapacity(v Uint64) *ConfigCellAccountBuilder {
	s.prepared_fee_capacity = v
	return s
}

func (s *ConfigCellAccountBuilder) ExpirationGracePeriod(v Uint32) *ConfigCellAccountBuilder {
	s.expiration_grace_period = v
	return s
}

func (s *ConfigCellAccountBuilder) RecordMinTtl(v Uint32) *ConfigCellAccountBuilder {
	s.record_min_ttl = v
	return s
}

func (s *ConfigCellAccountBuilder) RecordSizeLimit(v Uint32) *ConfigCellAccountBuilder {
	s.record_size_limit = v
	return s
}

func (s *ConfigCellAccountBuilder) TransferAccountFee(v Uint64) *ConfigCellAccountBuilder {
	s.transfer_account_fee = v
	return s
}

func (s *ConfigCellAccountBuilder) EditManagerFee(v Uint64) *ConfigCellAccountBuilder {
	s.edit_manager_fee = v
	return s
}

func (s *ConfigCellAccountBuilder) EditRecordsFee(v Uint64) *ConfigCellAccountBuilder {
	s.edit_records_fee = v
	return s
}

func (s *ConfigCellAccountBuilder) CommonFee(v Uint64) *ConfigCellAccountBuilder {
	s.common_fee = v
	return s
}

func (s *ConfigCellAccountBuilder) TransferAccountThrottle(v Uint32) *ConfigCellAccountBuilder {
	s.transfer_account_throttle = v
	return s
}

func (s *ConfigCellAccountBuilder) EditManagerThrottle(v Uint32) *ConfigCellAccountBuilder {
	s.edit_manager_throttle = v
	return s
}

func (s *ConfigCellAccountBuilder) EditRecordsThrottle(v Uint32) *ConfigCellAccountBuilder {
	s.edit_records_throttle = v
	return s
}

func (s *ConfigCellAccountBuilder) CommonThrottle(v Uint32) *ConfigCellAccountBuilder {
	s.common_throttle = v
	return s
}

func NewConfigCellAccountBuilder() *ConfigCellAccountBuilder {
	return &ConfigCellAccountBuilder{max_length: Uint32Default(), basic_capacity: Uint64Default(), prepared_fee_capacity: Uint64Default(), expiration_grace_period: Uint32Default(), record_min_ttl: Uint32Default(), record_size_limit: Uint32Default(), transfer_account_fee: Uint64Default(), edit_manager_fee: Uint64Default(), edit_records_fee: Uint64Default(), common_fee: Uint64Default(), transfer_account_throttle: Uint32Default(), edit_manager_throttle: Uint32Default(), edit_records_throttle: Uint32Default(), common_throttle: Uint32Default()}
}

type ConfigCellAccount struct {
	inner []byte
}

func ConfigCellAccountFromSliceUnchecked(slice []byte) *ConfigCellAccount {
	return &ConfigCellAccount{inner: slice}
}
func (s *ConfigCellAccount) AsSlice() []byte {
	return s.inner
}

func ConfigCellAccountDefault() ConfigCellAccount {
	return *ConfigCellAccountFromSliceUnchecked([]byte{140, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 92, 0, 0, 0, 100, 0, 0, 0, 108, 0, 0, 0, 116, 0, 0, 0, 124, 0, 0, 0, 128, 0, 0, 0, 132, 0, 0, 0, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellAccountFromSlice(slice []byte, compatible bool) (*ConfigCellAccount, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 14 == 0 {
		return &ConfigCellAccount{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellAccount", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 14 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 14 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[12]:offsets[13]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[13]:offsets[14]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellAccount{inner: slice}, nil
}

func (s *ConfigCellAccount) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellAccount) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellAccount) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellAccount) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellAccount) CountExtraFields() uint {
	return s.FieldCount() - 14
}

func (s *ConfigCellAccount) HasExtraFields() bool {
	return 14 != s.FieldCount()
}

func (s *ConfigCellAccount) MaxLength() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) BasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) PreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) ExpirationGracePeriod() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) RecordMinTtl() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) RecordSizeLimit() *Uint32 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) TransferAccountFee() *Uint64 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) EditManagerFee() *Uint64 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) EditRecordsFee() *Uint64 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) CommonFee() *Uint64 {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) TransferAccountThrottle() *Uint32 {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) EditManagerThrottle() *Uint32 {
	start := unpackNumber(s.inner[48:])
	end := unpackNumber(s.inner[52:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) EditRecordsThrottle() *Uint32 {
	start := unpackNumber(s.inner[52:])
	end := unpackNumber(s.inner[56:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccount) CommonThrottle() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[56:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[60:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellAccount) AsBuilder() ConfigCellAccountBuilder {
	ret := NewConfigCellAccountBuilder().MaxLength(*s.MaxLength()).BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).ExpirationGracePeriod(*s.ExpirationGracePeriod()).RecordMinTtl(*s.RecordMinTtl()).RecordSizeLimit(*s.RecordSizeLimit()).TransferAccountFee(*s.TransferAccountFee()).EditManagerFee(*s.EditManagerFee()).EditRecordsFee(*s.EditRecordsFee()).CommonFee(*s.CommonFee()).TransferAccountThrottle(*s.TransferAccountThrottle()).EditManagerThrottle(*s.EditManagerThrottle()).EditRecordsThrottle(*s.EditRecordsThrottle()).CommonThrottle(*s.CommonThrottle())
	return *ret
}

type ConfigCellApplyBuilder struct {
	apply_min_waiting_block_number Uint32
	apply_max_waiting_block_number Uint32
}

func (s *ConfigCellApplyBuilder) Build() ConfigCellApply {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_min_waiting_block_number.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_max_waiting_block_number.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.apply_min_waiting_block_number.AsSlice())
	b.Write(s.apply_max_waiting_block_number.AsSlice())
	return ConfigCellApply{inner: b.Bytes()}
}

func (s *ConfigCellApplyBuilder) ApplyMinWaitingBlockNumber(v Uint32) *ConfigCellApplyBuilder {
	s.apply_min_waiting_block_number = v
	return s
}

func (s *ConfigCellApplyBuilder) ApplyMaxWaitingBlockNumber(v Uint32) *ConfigCellApplyBuilder {
	s.apply_max_waiting_block_number = v
	return s
}

func NewConfigCellApplyBuilder() *ConfigCellApplyBuilder {
	return &ConfigCellApplyBuilder{apply_min_waiting_block_number: Uint32Default(), apply_max_waiting_block_number: Uint32Default()}
}

type ConfigCellApply struct {
	inner []byte
}

func ConfigCellApplyFromSliceUnchecked(slice []byte) *ConfigCellApply {
	return &ConfigCellApply{inner: slice}
}
func (s *ConfigCellApply) AsSlice() []byte {
	return s.inner
}

func ConfigCellApplyDefault() ConfigCellApply {
	return *ConfigCellApplyFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellApplyFromSlice(slice []byte, compatible bool) (*ConfigCellApply, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &ConfigCellApply{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellApply", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellApply{inner: slice}, nil
}

func (s *ConfigCellApply) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellApply) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellApply) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellApply) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellApply) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *ConfigCellApply) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *ConfigCellApply) ApplyMinWaitingBlockNumber() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellApply) ApplyMaxWaitingBlockNumber() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellApply) AsBuilder() ConfigCellApplyBuilder {
	ret := NewConfigCellApplyBuilder().ApplyMinWaitingBlockNumber(*s.ApplyMinWaitingBlockNumber()).ApplyMaxWaitingBlockNumber(*s.ApplyMaxWaitingBlockNumber())
	return *ret
}

type CharsBuilder struct {
	inner []Bytes
}

func (s *CharsBuilder) Build() Chars {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Chars{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Chars{inner: b.Bytes()}
}

func (s *CharsBuilder) Set(v []Bytes) *CharsBuilder {
	s.inner = v
	return s
}
func (s *CharsBuilder) Push(v Bytes) *CharsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *CharsBuilder) Extend(iter []Bytes) *CharsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewCharsBuilder() *CharsBuilder {
	return &CharsBuilder{[]Bytes{}}
}

type Chars struct {
	inner []byte
}

func CharsFromSliceUnchecked(slice []byte) *Chars {
	return &Chars{inner: slice}
}
func (s *Chars) AsSlice() []byte {
	return s.inner
}

func CharsDefault() Chars {
	return *CharsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func CharsFromSlice(slice []byte, compatible bool) (*Chars, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Chars{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := BytesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Chars{inner: slice}, nil
}

func (s *Chars) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Chars) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Chars) Len() uint {
	return s.ItemCount()
}
func (s *Chars) IsEmpty() bool {
	return s.Len() == 0
}

// if *Bytes is nil, index is out of bounds
func (s *Chars) Get(index uint) *Bytes {
	var b *Bytes
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Chars) AsBuilder() CharsBuilder {
	size := s.ItemCount()
	t := NewCharsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ConfigCellPriceBuilder struct {
	discount DiscountConfig
	prices   PriceConfigList
}

func (s *ConfigCellPriceBuilder) Build() ConfigCellPrice {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.discount.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.prices.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.discount.AsSlice())
	b.Write(s.prices.AsSlice())
	return ConfigCellPrice{inner: b.Bytes()}
}

func (s *ConfigCellPriceBuilder) Discount(v DiscountConfig) *ConfigCellPriceBuilder {
	s.discount = v
	return s
}

func (s *ConfigCellPriceBuilder) Prices(v PriceConfigList) *ConfigCellPriceBuilder {
	s.prices = v
	return s
}

func NewConfigCellPriceBuilder() *ConfigCellPriceBuilder {
	return &ConfigCellPriceBuilder{discount: DiscountConfigDefault(), prices: PriceConfigListDefault()}
}

type ConfigCellPrice struct {
	inner []byte
}

func ConfigCellPriceFromSliceUnchecked(slice []byte) *ConfigCellPrice {
	return &ConfigCellPrice{inner: slice}
}
func (s *ConfigCellPrice) AsSlice() []byte {
	return s.inner
}

func ConfigCellPriceDefault() ConfigCellPrice {
	return *ConfigCellPriceFromSliceUnchecked([]byte{28, 0, 0, 0, 12, 0, 0, 0, 24, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func ConfigCellPriceFromSlice(slice []byte, compatible bool) (*ConfigCellPrice, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &ConfigCellPrice{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellPrice", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DiscountConfigFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PriceConfigListFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellPrice{inner: slice}, nil
}

func (s *ConfigCellPrice) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellPrice) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellPrice) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellPrice) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellPrice) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *ConfigCellPrice) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *ConfigCellPrice) Discount() *DiscountConfig {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DiscountConfigFromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellPrice) Prices() *PriceConfigList {
	var ret *PriceConfigList
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = PriceConfigListFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = PriceConfigListFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellPrice) AsBuilder() ConfigCellPriceBuilder {
	ret := NewConfigCellPriceBuilder().Discount(*s.Discount()).Prices(*s.Prices())
	return *ret
}

type DiscountConfigBuilder struct {
	invited_discount Uint32
}

func (s *DiscountConfigBuilder) Build() DiscountConfig {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.invited_discount.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.invited_discount.AsSlice())
	return DiscountConfig{inner: b.Bytes()}
}

func (s *DiscountConfigBuilder) InvitedDiscount(v Uint32) *DiscountConfigBuilder {
	s.invited_discount = v
	return s
}

func NewDiscountConfigBuilder() *DiscountConfigBuilder {
	return &DiscountConfigBuilder{invited_discount: Uint32Default()}
}

type DiscountConfig struct {
	inner []byte
}

func DiscountConfigFromSliceUnchecked(slice []byte) *DiscountConfig {
	return &DiscountConfig{inner: slice}
}
func (s *DiscountConfig) AsSlice() []byte {
	return s.inner
}

func DiscountConfigDefault() DiscountConfig {
	return *DiscountConfigFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

func DiscountConfigFromSlice(slice []byte, compatible bool) (*DiscountConfig, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &DiscountConfig{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DiscountConfig", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &DiscountConfig{inner: slice}, nil
}

func (s *DiscountConfig) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DiscountConfig) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DiscountConfig) Len() uint {
	return s.FieldCount()
}
func (s *DiscountConfig) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DiscountConfig) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *DiscountConfig) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *DiscountConfig) InvitedDiscount() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DiscountConfig) AsBuilder() DiscountConfigBuilder {
	ret := NewDiscountConfigBuilder().InvitedDiscount(*s.InvitedDiscount())
	return *ret
}

type PriceConfigListBuilder struct {
	inner []PriceConfig
}

func (s *PriceConfigListBuilder) Build() PriceConfigList {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return PriceConfigList{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return PriceConfigList{inner: b.Bytes()}
}

func (s *PriceConfigListBuilder) Set(v []PriceConfig) *PriceConfigListBuilder {
	s.inner = v
	return s
}
func (s *PriceConfigListBuilder) Push(v PriceConfig) *PriceConfigListBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *PriceConfigListBuilder) Extend(iter []PriceConfig) *PriceConfigListBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewPriceConfigListBuilder() *PriceConfigListBuilder {
	return &PriceConfigListBuilder{[]PriceConfig{}}
}

type PriceConfigList struct {
	inner []byte
}

func PriceConfigListFromSliceUnchecked(slice []byte) *PriceConfigList {
	return &PriceConfigList{inner: slice}
}
func (s *PriceConfigList) AsSlice() []byte {
	return s.inner
}

func PriceConfigListDefault() PriceConfigList {
	return *PriceConfigListFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func PriceConfigListFromSlice(slice []byte, compatible bool) (*PriceConfigList, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &PriceConfigList{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := PriceConfigFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &PriceConfigList{inner: slice}, nil
}

func (s *PriceConfigList) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PriceConfigList) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PriceConfigList) Len() uint {
	return s.ItemCount()
}
func (s *PriceConfigList) IsEmpty() bool {
	return s.Len() == 0
}

// if *PriceConfig is nil, index is out of bounds
func (s *PriceConfigList) Get(index uint) *PriceConfig {
	var b *PriceConfig
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = PriceConfigFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = PriceConfigFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *PriceConfigList) AsBuilder() PriceConfigListBuilder {
	size := s.ItemCount()
	t := NewPriceConfigListBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type PriceConfigBuilder struct {
	length Uint8
	new    Uint64
	renew  Uint64
}

func (s *PriceConfigBuilder) Build() PriceConfig {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.new.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.renew.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.length.AsSlice())
	b.Write(s.new.AsSlice())
	b.Write(s.renew.AsSlice())
	return PriceConfig{inner: b.Bytes()}
}

func (s *PriceConfigBuilder) Length(v Uint8) *PriceConfigBuilder {
	s.length = v
	return s
}

func (s *PriceConfigBuilder) New(v Uint64) *PriceConfigBuilder {
	s.new = v
	return s
}

func (s *PriceConfigBuilder) Renew(v Uint64) *PriceConfigBuilder {
	s.renew = v
	return s
}

func NewPriceConfigBuilder() *PriceConfigBuilder {
	return &PriceConfigBuilder{length: Uint8Default(), new: Uint64Default(), renew: Uint64Default()}
}

type PriceConfig struct {
	inner []byte
}

func PriceConfigFromSliceUnchecked(slice []byte) *PriceConfig {
	return &PriceConfig{inner: slice}
}
func (s *PriceConfig) AsSlice() []byte {
	return s.inner
}

func PriceConfigDefault() PriceConfig {
	return *PriceConfigFromSliceUnchecked([]byte{33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func PriceConfigFromSlice(slice []byte, compatible bool) (*PriceConfig, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &PriceConfig{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfig", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &PriceConfig{inner: slice}, nil
}

func (s *PriceConfig) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PriceConfig) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PriceConfig) Len() uint {
	return s.FieldCount()
}
func (s *PriceConfig) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PriceConfig) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *PriceConfig) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *PriceConfig) Length() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *PriceConfig) New() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *PriceConfig) Renew() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PriceConfig) AsBuilder() PriceConfigBuilder {
	ret := NewPriceConfigBuilder().Length(*s.Length()).New(*s.New()).Renew(*s.Renew())
	return *ret
}

type ConfigCellProposalBuilder struct {
	proposal_min_confirm_interval    Uint8
	proposal_min_extend_interval     Uint8
	proposal_min_recycle_interval    Uint8
	proposal_max_account_affect      Uint32
	proposal_max_pre_account_contain Uint32
}

func (s *ConfigCellProposalBuilder) Build() ConfigCellProposal {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_min_confirm_interval.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_min_extend_interval.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_min_recycle_interval.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_max_account_affect.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_max_pre_account_contain.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.proposal_min_confirm_interval.AsSlice())
	b.Write(s.proposal_min_extend_interval.AsSlice())
	b.Write(s.proposal_min_recycle_interval.AsSlice())
	b.Write(s.proposal_max_account_affect.AsSlice())
	b.Write(s.proposal_max_pre_account_contain.AsSlice())
	return ConfigCellProposal{inner: b.Bytes()}
}

func (s *ConfigCellProposalBuilder) ProposalMinConfirmInterval(v Uint8) *ConfigCellProposalBuilder {
	s.proposal_min_confirm_interval = v
	return s
}

func (s *ConfigCellProposalBuilder) ProposalMinExtendInterval(v Uint8) *ConfigCellProposalBuilder {
	s.proposal_min_extend_interval = v
	return s
}

func (s *ConfigCellProposalBuilder) ProposalMinRecycleInterval(v Uint8) *ConfigCellProposalBuilder {
	s.proposal_min_recycle_interval = v
	return s
}

func (s *ConfigCellProposalBuilder) ProposalMaxAccountAffect(v Uint32) *ConfigCellProposalBuilder {
	s.proposal_max_account_affect = v
	return s
}

func (s *ConfigCellProposalBuilder) ProposalMaxPreAccountContain(v Uint32) *ConfigCellProposalBuilder {
	s.proposal_max_pre_account_contain = v
	return s
}

func NewConfigCellProposalBuilder() *ConfigCellProposalBuilder {
	return &ConfigCellProposalBuilder{proposal_min_confirm_interval: Uint8Default(), proposal_min_extend_interval: Uint8Default(), proposal_min_recycle_interval: Uint8Default(), proposal_max_account_affect: Uint32Default(), proposal_max_pre_account_contain: Uint32Default()}
}

type ConfigCellProposal struct {
	inner []byte
}

func ConfigCellProposalFromSliceUnchecked(slice []byte) *ConfigCellProposal {
	return &ConfigCellProposal{inner: slice}
}
func (s *ConfigCellProposal) AsSlice() []byte {
	return s.inner
}

func ConfigCellProposalDefault() ConfigCellProposal {
	return *ConfigCellProposalFromSliceUnchecked([]byte{35, 0, 0, 0, 24, 0, 0, 0, 25, 0, 0, 0, 26, 0, 0, 0, 27, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellProposalFromSlice(slice []byte, compatible bool) (*ConfigCellProposal, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &ConfigCellProposal{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProposal", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellProposal{inner: slice}, nil
}

func (s *ConfigCellProposal) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProposal) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellProposal) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellProposal) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellProposal) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *ConfigCellProposal) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *ConfigCellProposal) ProposalMinConfirmInterval() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProposal) ProposalMinExtendInterval() *Uint8 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProposal) ProposalMinRecycleInterval() *Uint8 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProposal) ProposalMaxAccountAffect() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProposal) ProposalMaxPreAccountContain() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellProposal) AsBuilder() ConfigCellProposalBuilder {
	ret := NewConfigCellProposalBuilder().ProposalMinConfirmInterval(*s.ProposalMinConfirmInterval()).ProposalMinExtendInterval(*s.ProposalMinExtendInterval()).ProposalMinRecycleInterval(*s.ProposalMinRecycleInterval()).ProposalMaxAccountAffect(*s.ProposalMaxAccountAffect()).ProposalMaxPreAccountContain(*s.ProposalMaxPreAccountContain())
	return *ret
}

type ConfigCellProfitRateBuilder struct {
	inviter                Uint32
	channel                Uint32
	proposal_create        Uint32
	proposal_confirm       Uint32
	income_consolidate     Uint32
	sale_buyer_inviter     Uint32
	sale_buyer_channel     Uint32
	sale_das               Uint32
	auction_bidder_inviter Uint32
	auction_bidder_channel Uint32
	auction_das            Uint32
	auction_prev_bidder    Uint32
}

func (s *ConfigCellProfitRateBuilder) Build() ConfigCellProfitRate {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (12 + 1)
	offsets := make([]uint32, 0, 12)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_create.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_confirm.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_consolidate.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_buyer_inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_buyer_channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_das.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_bidder_inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_bidder_channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_das.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_prev_bidder.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.inviter.AsSlice())
	b.Write(s.channel.AsSlice())
	b.Write(s.proposal_create.AsSlice())
	b.Write(s.proposal_confirm.AsSlice())
	b.Write(s.income_consolidate.AsSlice())
	b.Write(s.sale_buyer_inviter.AsSlice())
	b.Write(s.sale_buyer_channel.AsSlice())
	b.Write(s.sale_das.AsSlice())
	b.Write(s.auction_bidder_inviter.AsSlice())
	b.Write(s.auction_bidder_channel.AsSlice())
	b.Write(s.auction_das.AsSlice())
	b.Write(s.auction_prev_bidder.AsSlice())
	return ConfigCellProfitRate{inner: b.Bytes()}
}

func (s *ConfigCellProfitRateBuilder) Inviter(v Uint32) *ConfigCellProfitRateBuilder {
	s.inviter = v
	return s
}

func (s *ConfigCellProfitRateBuilder) Channel(v Uint32) *ConfigCellProfitRateBuilder {
	s.channel = v
	return s
}

func (s *ConfigCellProfitRateBuilder) ProposalCreate(v Uint32) *ConfigCellProfitRateBuilder {
	s.proposal_create = v
	return s
}

func (s *ConfigCellProfitRateBuilder) ProposalConfirm(v Uint32) *ConfigCellProfitRateBuilder {
	s.proposal_confirm = v
	return s
}

func (s *ConfigCellProfitRateBuilder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateBuilder {
	s.income_consolidate = v
	return s
}

func (s *ConfigCellProfitRateBuilder) SaleBuyerInviter(v Uint32) *ConfigCellProfitRateBuilder {
	s.sale_buyer_inviter = v
	return s
}

func (s *ConfigCellProfitRateBuilder) SaleBuyerChannel(v Uint32) *ConfigCellProfitRateBuilder {
	s.sale_buyer_channel = v
	return s
}

func (s *ConfigCellProfitRateBuilder) SaleDas(v Uint32) *ConfigCellProfitRateBuilder {
	s.sale_das = v
	return s
}

func (s *ConfigCellProfitRateBuilder) AuctionBidderInviter(v Uint32) *ConfigCellProfitRateBuilder {
	s.auction_bidder_inviter = v
	return s
}

func (s *ConfigCellProfitRateBuilder) AuctionBidderChannel(v Uint32) *ConfigCellProfitRateBuilder {
	s.auction_bidder_channel = v
	return s
}

func (s *ConfigCellProfitRateBuilder) AuctionDas(v Uint32) *ConfigCellProfitRateBuilder {
	s.auction_das = v
	return s
}

func (s *ConfigCellProfitRateBuilder) AuctionPrevBidder(v Uint32) *ConfigCellProfitRateBuilder {
	s.auction_prev_bidder = v
	return s
}

func NewConfigCellProfitRateBuilder() *ConfigCellProfitRateBuilder {
	return &ConfigCellProfitRateBuilder{inviter: Uint32Default(), channel: Uint32Default(), proposal_create: Uint32Default(), proposal_confirm: Uint32Default(), income_consolidate: Uint32Default(), sale_buyer_inviter: Uint32Default(), sale_buyer_channel: Uint32Default(), sale_das: Uint32Default(), auction_bidder_inviter: Uint32Default(), auction_bidder_channel: Uint32Default(), auction_das: Uint32Default(), auction_prev_bidder: Uint32Default()}
}

type ConfigCellProfitRate struct {
	inner []byte
}

func ConfigCellProfitRateFromSliceUnchecked(slice []byte) *ConfigCellProfitRate {
	return &ConfigCellProfitRate{inner: slice}
}
func (s *ConfigCellProfitRate) AsSlice() []byte {
	return s.inner
}

func ConfigCellProfitRateDefault() ConfigCellProfitRate {
	return *ConfigCellProfitRateFromSliceUnchecked([]byte{100, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 92, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellProfitRateFromSlice(slice []byte, compatible bool) (*ConfigCellProfitRate, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 12 == 0 {
		return &ConfigCellProfitRate{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 12 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 12 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellProfitRate{inner: slice}, nil
}

func (s *ConfigCellProfitRate) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRate) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellProfitRate) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellProfitRate) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellProfitRate) CountExtraFields() uint {
	return s.FieldCount() - 12
}

func (s *ConfigCellProfitRate) HasExtraFields() bool {
	return 12 != s.FieldCount()
}

func (s *ConfigCellProfitRate) Inviter() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) Channel() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) ProposalCreate() *Uint32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) ProposalConfirm() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) IncomeConsolidate() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) SaleBuyerInviter() *Uint32 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) SaleBuyerChannel() *Uint32 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) SaleDas() *Uint32 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) AuctionBidderInviter() *Uint32 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) AuctionBidderChannel() *Uint32 {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) AuctionDas() *Uint32 {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRate) AuctionPrevBidder() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[48:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[52:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellProfitRate) AsBuilder() ConfigCellProfitRateBuilder {
	ret := NewConfigCellProfitRateBuilder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate()).SaleBuyerInviter(*s.SaleBuyerInviter()).SaleBuyerChannel(*s.SaleBuyerChannel()).SaleDas(*s.SaleDas()).AuctionBidderInviter(*s.AuctionBidderInviter()).AuctionBidderChannel(*s.AuctionBidderChannel()).AuctionDas(*s.AuctionDas()).AuctionPrevBidder(*s.AuctionPrevBidder())
	return *ret
}

type ConfigCellIncomeBuilder struct {
	basic_capacity        Uint64
	max_records           Uint32
	min_transfer_capacity Uint64
}

func (s *ConfigCellIncomeBuilder) Build() ConfigCellIncome {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.max_records.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.min_transfer_capacity.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.basic_capacity.AsSlice())
	b.Write(s.max_records.AsSlice())
	b.Write(s.min_transfer_capacity.AsSlice())
	return ConfigCellIncome{inner: b.Bytes()}
}

func (s *ConfigCellIncomeBuilder) BasicCapacity(v Uint64) *ConfigCellIncomeBuilder {
	s.basic_capacity = v
	return s
}

func (s *ConfigCellIncomeBuilder) MaxRecords(v Uint32) *ConfigCellIncomeBuilder {
	s.max_records = v
	return s
}

func (s *ConfigCellIncomeBuilder) MinTransferCapacity(v Uint64) *ConfigCellIncomeBuilder {
	s.min_transfer_capacity = v
	return s
}

func NewConfigCellIncomeBuilder() *ConfigCellIncomeBuilder {
	return &ConfigCellIncomeBuilder{basic_capacity: Uint64Default(), max_records: Uint32Default(), min_transfer_capacity: Uint64Default()}
}

type ConfigCellIncome struct {
	inner []byte
}

func ConfigCellIncomeFromSliceUnchecked(slice []byte) *ConfigCellIncome {
	return &ConfigCellIncome{inner: slice}
}
func (s *ConfigCellIncome) AsSlice() []byte {
	return s.inner
}

func ConfigCellIncomeDefault() ConfigCellIncome {
	return *ConfigCellIncomeFromSliceUnchecked([]byte{36, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellIncomeFromSlice(slice []byte, compatible bool) (*ConfigCellIncome, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ConfigCellIncome{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellIncome", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellIncome{inner: slice}, nil
}

func (s *ConfigCellIncome) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellIncome) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellIncome) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellIncome) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellIncome) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellIncome) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellIncome) BasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellIncome) MaxRecords() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellIncome) MinTransferCapacity() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellIncome) AsBuilder() ConfigCellIncomeBuilder {
	ret := NewConfigCellIncomeBuilder().BasicCapacity(*s.BasicCapacity()).MaxRecords(*s.MaxRecords()).MinTransferCapacity(*s.MinTransferCapacity())
	return *ret
}

type ConfigCellReleaseBuilder struct {
	release_rules ReleaseRules
}

func (s *ConfigCellReleaseBuilder) Build() ConfigCellRelease {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.release_rules.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.release_rules.AsSlice())
	return ConfigCellRelease{inner: b.Bytes()}
}

func (s *ConfigCellReleaseBuilder) ReleaseRules(v ReleaseRules) *ConfigCellReleaseBuilder {
	s.release_rules = v
	return s
}

func NewConfigCellReleaseBuilder() *ConfigCellReleaseBuilder {
	return &ConfigCellReleaseBuilder{release_rules: ReleaseRulesDefault()}
}

type ConfigCellRelease struct {
	inner []byte
}

func ConfigCellReleaseFromSliceUnchecked(slice []byte) *ConfigCellRelease {
	return &ConfigCellRelease{inner: slice}
}
func (s *ConfigCellRelease) AsSlice() []byte {
	return s.inner
}

func ConfigCellReleaseDefault() ConfigCellRelease {
	return *ConfigCellReleaseFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0})
}

func ConfigCellReleaseFromSlice(slice []byte, compatible bool) (*ConfigCellRelease, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &ConfigCellRelease{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellRelease", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ReleaseRulesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellRelease{inner: slice}, nil
}

func (s *ConfigCellRelease) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellRelease) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellRelease) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellRelease) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellRelease) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *ConfigCellRelease) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *ConfigCellRelease) ReleaseRules() *ReleaseRules {
	var ret *ReleaseRules
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = ReleaseRulesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ReleaseRulesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellRelease) AsBuilder() ConfigCellReleaseBuilder {
	ret := NewConfigCellReleaseBuilder().ReleaseRules(*s.ReleaseRules())
	return *ret
}

type ReleaseRulesBuilder struct {
	inner []ReleaseRule
}

func (s *ReleaseRulesBuilder) Build() ReleaseRules {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return ReleaseRules{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return ReleaseRules{inner: b.Bytes()}
}

func (s *ReleaseRulesBuilder) Set(v []ReleaseRule) *ReleaseRulesBuilder {
	s.inner = v
	return s
}
func (s *ReleaseRulesBuilder) Push(v ReleaseRule) *ReleaseRulesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ReleaseRulesBuilder) Extend(iter []ReleaseRule) *ReleaseRulesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewReleaseRulesBuilder() *ReleaseRulesBuilder {
	return &ReleaseRulesBuilder{[]ReleaseRule{}}
}

type ReleaseRules struct {
	inner []byte
}

func ReleaseRulesFromSliceUnchecked(slice []byte) *ReleaseRules {
	return &ReleaseRules{inner: slice}
}
func (s *ReleaseRules) AsSlice() []byte {
	return s.inner
}

func ReleaseRulesDefault() ReleaseRules {
	return *ReleaseRulesFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func ReleaseRulesFromSlice(slice []byte, compatible bool) (*ReleaseRules, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ReleaseRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ReleaseRules", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &ReleaseRules{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ReleaseRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ReleaseRules", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ReleaseRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "ReleaseRules"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := ReleaseRuleFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &ReleaseRules{inner: slice}, nil
}

func (s *ReleaseRules) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ReleaseRules) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ReleaseRules) Len() uint {
	return s.ItemCount()
}
func (s *ReleaseRules) IsEmpty() bool {
	return s.Len() == 0
}

// if *ReleaseRule is nil, index is out of bounds
func (s *ReleaseRules) Get(index uint) *ReleaseRule {
	var b *ReleaseRule
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = ReleaseRuleFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = ReleaseRuleFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *ReleaseRules) AsBuilder() ReleaseRulesBuilder {
	size := s.ItemCount()
	t := NewReleaseRulesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ReleaseRuleBuilder struct {
	length        Uint32
	release_start Timestamp
	release_end   Timestamp
}

func (s *ReleaseRuleBuilder) Build() ReleaseRule {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.release_start.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.release_end.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.length.AsSlice())
	b.Write(s.release_start.AsSlice())
	b.Write(s.release_end.AsSlice())
	return ReleaseRule{inner: b.Bytes()}
}

func (s *ReleaseRuleBuilder) Length(v Uint32) *ReleaseRuleBuilder {
	s.length = v
	return s
}

func (s *ReleaseRuleBuilder) ReleaseStart(v Timestamp) *ReleaseRuleBuilder {
	s.release_start = v
	return s
}

func (s *ReleaseRuleBuilder) ReleaseEnd(v Timestamp) *ReleaseRuleBuilder {
	s.release_end = v
	return s
}

func NewReleaseRuleBuilder() *ReleaseRuleBuilder {
	return &ReleaseRuleBuilder{length: Uint32Default(), release_start: TimestampDefault(), release_end: TimestampDefault()}
}

type ReleaseRule struct {
	inner []byte
}

func ReleaseRuleFromSliceUnchecked(slice []byte) *ReleaseRule {
	return &ReleaseRule{inner: slice}
}
func (s *ReleaseRule) AsSlice() []byte {
	return s.inner
}

func ReleaseRuleDefault() ReleaseRule {
	return *ReleaseRuleFromSliceUnchecked([]byte{36, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ReleaseRuleFromSlice(slice []byte, compatible bool) (*ReleaseRule, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ReleaseRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ReleaseRule", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ReleaseRule{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ReleaseRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ReleaseRule", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ReleaseRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ReleaseRule{inner: slice}, nil
}

func (s *ReleaseRule) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ReleaseRule) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ReleaseRule) Len() uint {
	return s.FieldCount()
}
func (s *ReleaseRule) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ReleaseRule) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ReleaseRule) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ReleaseRule) Length() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ReleaseRule) ReleaseStart() *Timestamp {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *ReleaseRule) ReleaseEnd() *Timestamp {
	var ret *Timestamp
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = TimestampFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TimestampFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ReleaseRule) AsBuilder() ReleaseRuleBuilder {
	ret := NewReleaseRuleBuilder().Length(*s.Length()).ReleaseStart(*s.ReleaseStart()).ReleaseEnd(*s.ReleaseEnd())
	return *ret
}

type ConfigCellSecondaryMarketBuilder struct {
	common_fee                          Uint64
	sale_min_price                      Uint64
	sale_expiration_limit               Uint32
	sale_description_bytes_limit        Uint32
	sale_cell_basic_capacity            Uint64
	sale_cell_prepared_fee_capacity     Uint64
	auction_max_extendable_duration     Uint32
	auction_duration_increment_each_bid Uint32
	auction_min_opening_price           Uint64
	auction_min_increment_rate_each_bid Uint32
	auction_description_bytes_limit     Uint32
	auction_cell_basic_capacity         Uint64
	auction_cell_prepared_fee_capacity  Uint64
	offer_min_price                     Uint64
	offer_cell_basic_capacity           Uint64
	offer_cell_prepared_fee_capacity    Uint64
	offer_message_bytes_limit           Uint32
}

func (s *ConfigCellSecondaryMarketBuilder) Build() ConfigCellSecondaryMarket {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (17 + 1)
	offsets := make([]uint32, 0, 17)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.common_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_min_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_cell_basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_cell_prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_max_extendable_duration.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_duration_increment_each_bid.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_min_opening_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_min_increment_rate_each_bid.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_description_bytes_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_cell_basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_cell_prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_min_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell_basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell_prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_message_bytes_limit.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.common_fee.AsSlice())
	b.Write(s.sale_min_price.AsSlice())
	b.Write(s.sale_expiration_limit.AsSlice())
	b.Write(s.sale_description_bytes_limit.AsSlice())
	b.Write(s.sale_cell_basic_capacity.AsSlice())
	b.Write(s.sale_cell_prepared_fee_capacity.AsSlice())
	b.Write(s.auction_max_extendable_duration.AsSlice())
	b.Write(s.auction_duration_increment_each_bid.AsSlice())
	b.Write(s.auction_min_opening_price.AsSlice())
	b.Write(s.auction_min_increment_rate_each_bid.AsSlice())
	b.Write(s.auction_description_bytes_limit.AsSlice())
	b.Write(s.auction_cell_basic_capacity.AsSlice())
	b.Write(s.auction_cell_prepared_fee_capacity.AsSlice())
	b.Write(s.offer_min_price.AsSlice())
	b.Write(s.offer_cell_basic_capacity.AsSlice())
	b.Write(s.offer_cell_prepared_fee_capacity.AsSlice())
	b.Write(s.offer_message_bytes_limit.AsSlice())
	return ConfigCellSecondaryMarket{inner: b.Bytes()}
}

func (s *ConfigCellSecondaryMarketBuilder) CommonFee(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.common_fee = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) SaleMinPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.sale_min_price = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) SaleExpirationLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.sale_expiration_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.sale_description_bytes_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) SaleCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.sale_cell_basic_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) SaleCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.sale_cell_prepared_fee_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionMaxExtendableDuration(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.auction_max_extendable_duration = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionDurationIncrementEachBid(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.auction_duration_increment_each_bid = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionMinOpeningPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.auction_min_opening_price = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionMinIncrementRateEachBid(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.auction_min_increment_rate_each_bid = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.auction_description_bytes_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.auction_cell_basic_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) AuctionCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.auction_cell_prepared_fee_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) OfferMinPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.offer_min_price = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) OfferCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.offer_cell_basic_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) OfferCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
	s.offer_cell_prepared_fee_capacity = v
	return s
}

func (s *ConfigCellSecondaryMarketBuilder) OfferMessageBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
	s.offer_message_bytes_limit = v
	return s
}

func NewConfigCellSecondaryMarketBuilder() *ConfigCellSecondaryMarketBuilder {
	return &ConfigCellSecondaryMarketBuilder{common_fee: Uint64Default(), sale_min_price: Uint64Default(), sale_expiration_limit: Uint32Default(), sale_description_bytes_limit: Uint32Default(), sale_cell_basic_capacity: Uint64Default(), sale_cell_prepared_fee_capacity: Uint64Default(), auction_max_extendable_duration: Uint32Default(), auction_duration_increment_each_bid: Uint32Default(), auction_min_opening_price: Uint64Default(), auction_min_increment_rate_each_bid: Uint32Default(), auction_description_bytes_limit: Uint32Default(), auction_cell_basic_capacity: Uint64Default(), auction_cell_prepared_fee_capacity: Uint64Default(), offer_min_price: Uint64Default(), offer_cell_basic_capacity: Uint64Default(), offer_cell_prepared_fee_capacity: Uint64Default(), offer_message_bytes_limit: Uint32Default()}
}

type ConfigCellSecondaryMarket struct {
	inner []byte
}

func ConfigCellSecondaryMarketFromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarket {
	return &ConfigCellSecondaryMarket{inner: slice}
}
func (s *ConfigCellSecondaryMarket) AsSlice() []byte {
	return s.inner
}

func ConfigCellSecondaryMarketDefault() ConfigCellSecondaryMarket {
	return *ConfigCellSecondaryMarketFromSliceUnchecked([]byte{180, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 88, 0, 0, 0, 92, 0, 0, 0, 96, 0, 0, 0, 104, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 120, 0, 0, 0, 128, 0, 0, 0, 132, 0, 0, 0, 136, 0, 0, 0, 144, 0, 0, 0, 152, 0, 0, 0, 160, 0, 0, 0, 168, 0, 0, 0, 176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellSecondaryMarketFromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarket, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 17 == 0 {
		return &ConfigCellSecondaryMarket{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 17 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 17 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[12]:offsets[13]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[13]:offsets[14]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[14]:offsets[15]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[15]:offsets[16]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[16]:offsets[17]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellSecondaryMarket{inner: slice}, nil
}

func (s *ConfigCellSecondaryMarket) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarket) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellSecondaryMarket) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellSecondaryMarket) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellSecondaryMarket) CountExtraFields() uint {
	return s.FieldCount() - 17
}

func (s *ConfigCellSecondaryMarket) HasExtraFields() bool {
	return 17 != s.FieldCount()
}

func (s *ConfigCellSecondaryMarket) CommonFee() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) SaleMinPrice() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) SaleExpirationLimit() *Uint32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) SaleDescriptionBytesLimit() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) SaleCellBasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) SaleCellPreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionMaxExtendableDuration() *Uint32 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionDurationIncrementEachBid() *Uint32 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionMinOpeningPrice() *Uint64 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionMinIncrementRateEachBid() *Uint32 {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionDescriptionBytesLimit() *Uint32 {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionCellBasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[48:])
	end := unpackNumber(s.inner[52:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) AuctionCellPreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[52:])
	end := unpackNumber(s.inner[56:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) OfferMinPrice() *Uint64 {
	start := unpackNumber(s.inner[56:])
	end := unpackNumber(s.inner[60:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) OfferCellBasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[60:])
	end := unpackNumber(s.inner[64:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) OfferCellPreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[64:])
	end := unpackNumber(s.inner[68:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarket) OfferMessageBytesLimit() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[68:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[72:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellSecondaryMarket) AsBuilder() ConfigCellSecondaryMarketBuilder {
	ret := NewConfigCellSecondaryMarketBuilder().CommonFee(*s.CommonFee()).SaleMinPrice(*s.SaleMinPrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit()).SaleCellBasicCapacity(*s.SaleCellBasicCapacity()).SaleCellPreparedFeeCapacity(*s.SaleCellPreparedFeeCapacity()).AuctionMaxExtendableDuration(*s.AuctionMaxExtendableDuration()).AuctionDurationIncrementEachBid(*s.AuctionDurationIncrementEachBid()).AuctionMinOpeningPrice(*s.AuctionMinOpeningPrice()).AuctionMinIncrementRateEachBid(*s.AuctionMinIncrementRateEachBid()).AuctionDescriptionBytesLimit(*s.AuctionDescriptionBytesLimit()).AuctionCellBasicCapacity(*s.AuctionCellBasicCapacity()).AuctionCellPreparedFeeCapacity(*s.AuctionCellPreparedFeeCapacity()).OfferMinPrice(*s.OfferMinPrice()).OfferCellBasicCapacity(*s.OfferCellBasicCapacity()).OfferCellPreparedFeeCapacity(*s.OfferCellPreparedFeeCapacity()).OfferMessageBytesLimit(*s.OfferMessageBytesLimit())
	return *ret
}

type ConfigCellReverseResolutionBuilder struct {
	record_basic_capacity        Uint64
	record_prepared_fee_capacity Uint64
	common_fee                   Uint64
}

func (s *ConfigCellReverseResolutionBuilder) Build() ConfigCellReverseResolution {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.common_fee.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.record_basic_capacity.AsSlice())
	b.Write(s.record_prepared_fee_capacity.AsSlice())
	b.Write(s.common_fee.AsSlice())
	return ConfigCellReverseResolution{inner: b.Bytes()}
}

func (s *ConfigCellReverseResolutionBuilder) RecordBasicCapacity(v Uint64) *ConfigCellReverseResolutionBuilder {
	s.record_basic_capacity = v
	return s
}

func (s *ConfigCellReverseResolutionBuilder) RecordPreparedFeeCapacity(v Uint64) *ConfigCellReverseResolutionBuilder {
	s.record_prepared_fee_capacity = v
	return s
}

func (s *ConfigCellReverseResolutionBuilder) CommonFee(v Uint64) *ConfigCellReverseResolutionBuilder {
	s.common_fee = v
	return s
}

func NewConfigCellReverseResolutionBuilder() *ConfigCellReverseResolutionBuilder {
	return &ConfigCellReverseResolutionBuilder{record_basic_capacity: Uint64Default(), record_prepared_fee_capacity: Uint64Default(), common_fee: Uint64Default()}
}

type ConfigCellReverseResolution struct {
	inner []byte
}

func ConfigCellReverseResolutionFromSliceUnchecked(slice []byte) *ConfigCellReverseResolution {
	return &ConfigCellReverseResolution{inner: slice}
}
func (s *ConfigCellReverseResolution) AsSlice() []byte {
	return s.inner
}

func ConfigCellReverseResolutionDefault() ConfigCellReverseResolution {
	return *ConfigCellReverseResolutionFromSliceUnchecked([]byte{40, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellReverseResolutionFromSlice(slice []byte, compatible bool) (*ConfigCellReverseResolution, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ConfigCellReverseResolution{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellReverseResolution{inner: slice}, nil
}

func (s *ConfigCellReverseResolution) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellReverseResolution) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellReverseResolution) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellReverseResolution) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellReverseResolution) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellReverseResolution) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellReverseResolution) RecordBasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellReverseResolution) RecordPreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellReverseResolution) CommonFee() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellReverseResolution) AsBuilder() ConfigCellReverseResolutionBuilder {
	ret := NewConfigCellReverseResolutionBuilder().RecordBasicCapacity(*s.RecordBasicCapacity()).RecordPreparedFeeCapacity(*s.RecordPreparedFeeCapacity()).CommonFee(*s.CommonFee())
	return *ret
}

type ProposalCellDataBuilder struct {
	proposer_lock     Script
	created_at_height Uint64
	slices            SliceList
}

func (s *ProposalCellDataBuilder) Build() ProposalCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposer_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.created_at_height.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.slices.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.proposer_lock.AsSlice())
	b.Write(s.created_at_height.AsSlice())
	b.Write(s.slices.AsSlice())
	return ProposalCellData{inner: b.Bytes()}
}

func (s *ProposalCellDataBuilder) ProposerLock(v Script) *ProposalCellDataBuilder {
	s.proposer_lock = v
	return s
}

func (s *ProposalCellDataBuilder) CreatedAtHeight(v Uint64) *ProposalCellDataBuilder {
	s.created_at_height = v
	return s
}

func (s *ProposalCellDataBuilder) Slices(v SliceList) *ProposalCellDataBuilder {
	s.slices = v
	return s
}

func NewProposalCellDataBuilder() *ProposalCellDataBuilder {
	return &ProposalCellDataBuilder{proposer_lock: ScriptDefault(), created_at_height: Uint64Default(), slices: SliceListDefault()}
}

type ProposalCellData struct {
	inner []byte
}

func ProposalCellDataFromSliceUnchecked(slice []byte) *ProposalCellData {
	return &ProposalCellData{inner: slice}
}
func (s *ProposalCellData) AsSlice() []byte {
	return s.inner
}

func ProposalCellDataDefault() ProposalCellData {
	return *ProposalCellDataFromSliceUnchecked([]byte{81, 0, 0, 0, 16, 0, 0, 0, 69, 0, 0, 0, 77, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func ProposalCellDataFromSlice(slice []byte, compatible bool) (*ProposalCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ProposalCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SliceListFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ProposalCellData{inner: slice}, nil
}

func (s *ProposalCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ProposalCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ProposalCellData) Len() uint {
	return s.FieldCount()
}
func (s *ProposalCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ProposalCellData) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ProposalCellData) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ProposalCellData) ProposerLock() *Script {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalCellData) CreatedAtHeight() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalCellData) Slices() *SliceList {
	var ret *SliceList
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = SliceListFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SliceListFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ProposalCellData) AsBuilder() ProposalCellDataBuilder {
	ret := NewProposalCellDataBuilder().ProposerLock(*s.ProposerLock()).CreatedAtHeight(*s.CreatedAtHeight()).Slices(*s.Slices())
	return *ret
}

type SliceListBuilder struct {
	inner []SL
}

func (s *SliceListBuilder) Build() SliceList {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SliceList{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SliceList{inner: b.Bytes()}
}

func (s *SliceListBuilder) Set(v []SL) *SliceListBuilder {
	s.inner = v
	return s
}
func (s *SliceListBuilder) Push(v SL) *SliceListBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SliceListBuilder) Extend(iter []SL) *SliceListBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewSliceListBuilder() *SliceListBuilder {
	return &SliceListBuilder{[]SL{}}
}

type SliceList struct {
	inner []byte
}

func SliceListFromSliceUnchecked(slice []byte) *SliceList {
	return &SliceList{inner: slice}
}
func (s *SliceList) AsSlice() []byte {
	return s.inner
}

func SliceListDefault() SliceList {
	return *SliceListFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SliceListFromSlice(slice []byte, compatible bool) (*SliceList, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SliceList{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := SLFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SliceList{inner: slice}, nil
}

func (s *SliceList) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SliceList) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SliceList) Len() uint {
	return s.ItemCount()
}
func (s *SliceList) IsEmpty() bool {
	return s.Len() == 0
}

// if *SL is nil, index is out of bounds
func (s *SliceList) Get(index uint) *SL {
	var b *SL
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = SLFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = SLFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SliceList) AsBuilder() SliceListBuilder {
	size := s.ItemCount()
	t := NewSliceListBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SLBuilder struct {
	inner []ProposalItem
}

func (s *SLBuilder) Build() SL {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SL{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SL{inner: b.Bytes()}
}

func (s *SLBuilder) Set(v []ProposalItem) *SLBuilder {
	s.inner = v
	return s
}
func (s *SLBuilder) Push(v ProposalItem) *SLBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SLBuilder) Extend(iter []ProposalItem) *SLBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewSLBuilder() *SLBuilder {
	return &SLBuilder{[]ProposalItem{}}
}

type SL struct {
	inner []byte
}

func SLFromSliceUnchecked(slice []byte) *SL {
	return &SL{inner: slice}
}
func (s *SL) AsSlice() []byte {
	return s.inner
}

func SLDefault() SL {
	return *SLFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SLFromSlice(slice []byte, compatible bool) (*SL, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SL{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SL", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SL"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := ProposalItemFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SL{inner: slice}, nil
}

func (s *SL) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SL) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SL) Len() uint {
	return s.ItemCount()
}
func (s *SL) IsEmpty() bool {
	return s.Len() == 0
}

// if *ProposalItem is nil, index is out of bounds
func (s *SL) Get(index uint) *ProposalItem {
	var b *ProposalItem
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = ProposalItemFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = ProposalItemFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SL) AsBuilder() SLBuilder {
	size := s.ItemCount()
	t := NewSLBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ProposalItemBuilder struct {
	account_id AccountId
	item_type  Uint8
	next       AccountId
}

func (s *ProposalItemBuilder) Build() ProposalItem {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.item_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.next.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_id.AsSlice())
	b.Write(s.item_type.AsSlice())
	b.Write(s.next.AsSlice())
	return ProposalItem{inner: b.Bytes()}
}

func (s *ProposalItemBuilder) AccountId(v AccountId) *ProposalItemBuilder {
	s.account_id = v
	return s
}

func (s *ProposalItemBuilder) ItemType(v Uint8) *ProposalItemBuilder {
	s.item_type = v
	return s
}

func (s *ProposalItemBuilder) Next(v AccountId) *ProposalItemBuilder {
	s.next = v
	return s
}

func NewProposalItemBuilder() *ProposalItemBuilder {
	return &ProposalItemBuilder{account_id: AccountIdDefault(), item_type: Uint8Default(), next: AccountIdDefault()}
}

type ProposalItem struct {
	inner []byte
}

func ProposalItemFromSliceUnchecked(slice []byte) *ProposalItem {
	return &ProposalItem{inner: slice}
}
func (s *ProposalItem) AsSlice() []byte {
	return s.inner
}

func ProposalItemDefault() ProposalItem {
	return *ProposalItemFromSliceUnchecked([]byte{57, 0, 0, 0, 16, 0, 0, 0, 36, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ProposalItemFromSlice(slice []byte, compatible bool) (*ProposalItem, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ProposalItem{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalItem", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountIdFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ProposalItem{inner: slice}, nil
}

func (s *ProposalItem) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ProposalItem) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ProposalItem) Len() uint {
	return s.FieldCount()
}
func (s *ProposalItem) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ProposalItem) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ProposalItem) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ProposalItem) AccountId() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalItem) ItemType() *Uint8 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalItem) Next() *AccountId {
	var ret *AccountId
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = AccountIdFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = AccountIdFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ProposalItem) AsBuilder() ProposalItemBuilder {
	ret := NewProposalItemBuilder().AccountId(*s.AccountId()).ItemType(*s.ItemType()).Next(*s.Next())
	return *ret
}

type IncomeCellDataBuilder struct {
	creator Script
	records IncomeRecords
}

func (s *IncomeCellDataBuilder) Build() IncomeCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.creator.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.records.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.creator.AsSlice())
	b.Write(s.records.AsSlice())
	return IncomeCellData{inner: b.Bytes()}
}

func (s *IncomeCellDataBuilder) Creator(v Script) *IncomeCellDataBuilder {
	s.creator = v
	return s
}

func (s *IncomeCellDataBuilder) Records(v IncomeRecords) *IncomeCellDataBuilder {
	s.records = v
	return s
}

func NewIncomeCellDataBuilder() *IncomeCellDataBuilder {
	return &IncomeCellDataBuilder{creator: ScriptDefault(), records: IncomeRecordsDefault()}
}

type IncomeCellData struct {
	inner []byte
}

func IncomeCellDataFromSliceUnchecked(slice []byte) *IncomeCellData {
	return &IncomeCellData{inner: slice}
}
func (s *IncomeCellData) AsSlice() []byte {
	return s.inner
}

func IncomeCellDataDefault() IncomeCellData {
	return *IncomeCellDataFromSliceUnchecked([]byte{69, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func IncomeCellDataFromSlice(slice []byte, compatible bool) (*IncomeCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &IncomeCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = IncomeRecordsFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &IncomeCellData{inner: slice}, nil
}

func (s *IncomeCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *IncomeCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *IncomeCellData) Len() uint {
	return s.FieldCount()
}
func (s *IncomeCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *IncomeCellData) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *IncomeCellData) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *IncomeCellData) Creator() *Script {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *IncomeCellData) Records() *IncomeRecords {
	var ret *IncomeRecords
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = IncomeRecordsFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = IncomeRecordsFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *IncomeCellData) AsBuilder() IncomeCellDataBuilder {
	ret := NewIncomeCellDataBuilder().Creator(*s.Creator()).Records(*s.Records())
	return *ret
}

type IncomeRecordsBuilder struct {
	inner []IncomeRecord
}

func (s *IncomeRecordsBuilder) Build() IncomeRecords {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return IncomeRecords{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return IncomeRecords{inner: b.Bytes()}
}

func (s *IncomeRecordsBuilder) Set(v []IncomeRecord) *IncomeRecordsBuilder {
	s.inner = v
	return s
}
func (s *IncomeRecordsBuilder) Push(v IncomeRecord) *IncomeRecordsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *IncomeRecordsBuilder) Extend(iter []IncomeRecord) *IncomeRecordsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewIncomeRecordsBuilder() *IncomeRecordsBuilder {
	return &IncomeRecordsBuilder{[]IncomeRecord{}}
}

type IncomeRecords struct {
	inner []byte
}

func IncomeRecordsFromSliceUnchecked(slice []byte) *IncomeRecords {
	return &IncomeRecords{inner: slice}
}
func (s *IncomeRecords) AsSlice() []byte {
	return s.inner
}

func IncomeRecordsDefault() IncomeRecords {
	return *IncomeRecordsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func IncomeRecordsFromSlice(slice []byte, compatible bool) (*IncomeRecords, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecords", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &IncomeRecords{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecords", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecords"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := IncomeRecordFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &IncomeRecords{inner: slice}, nil
}

func (s *IncomeRecords) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *IncomeRecords) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *IncomeRecords) Len() uint {
	return s.ItemCount()
}
func (s *IncomeRecords) IsEmpty() bool {
	return s.Len() == 0
}

// if *IncomeRecord is nil, index is out of bounds
func (s *IncomeRecords) Get(index uint) *IncomeRecord {
	var b *IncomeRecord
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = IncomeRecordFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = IncomeRecordFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *IncomeRecords) AsBuilder() IncomeRecordsBuilder {
	size := s.ItemCount()
	t := NewIncomeRecordsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type IncomeRecordBuilder struct {
	belong_to Script
	capacity  Uint64
}

func (s *IncomeRecordBuilder) Build() IncomeRecord {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.belong_to.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.capacity.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.belong_to.AsSlice())
	b.Write(s.capacity.AsSlice())
	return IncomeRecord{inner: b.Bytes()}
}

func (s *IncomeRecordBuilder) BelongTo(v Script) *IncomeRecordBuilder {
	s.belong_to = v
	return s
}

func (s *IncomeRecordBuilder) Capacity(v Uint64) *IncomeRecordBuilder {
	s.capacity = v
	return s
}

func NewIncomeRecordBuilder() *IncomeRecordBuilder {
	return &IncomeRecordBuilder{belong_to: ScriptDefault(), capacity: Uint64Default()}
}

type IncomeRecord struct {
	inner []byte
}

func IncomeRecordFromSliceUnchecked(slice []byte) *IncomeRecord {
	return &IncomeRecord{inner: slice}
}
func (s *IncomeRecord) AsSlice() []byte {
	return s.inner
}

func IncomeRecordDefault() IncomeRecord {
	return *IncomeRecordFromSliceUnchecked([]byte{73, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func IncomeRecordFromSlice(slice []byte, compatible bool) (*IncomeRecord, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecord", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &IncomeRecord{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecord", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &IncomeRecord{inner: slice}, nil
}

func (s *IncomeRecord) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *IncomeRecord) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *IncomeRecord) Len() uint {
	return s.FieldCount()
}
func (s *IncomeRecord) IsEmpty() bool {
	return s.Len() == 0
}
func (s *IncomeRecord) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *IncomeRecord) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *IncomeRecord) BelongTo() *Script {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *IncomeRecord) Capacity() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *IncomeRecord) AsBuilder() IncomeRecordBuilder {
	ret := NewIncomeRecordBuilder().BelongTo(*s.BelongTo()).Capacity(*s.Capacity())
	return *ret
}

type AccountCellDataV1Builder struct {
	id            AccountId
	account       AccountChars
	registered_at Uint64
	updated_at    Uint64
	status        Uint8
	records       Records
}

func (s *AccountCellDataV1Builder) Build() AccountCellDataV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registered_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.updated_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.records.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.registered_at.AsSlice())
	b.Write(s.updated_at.AsSlice())
	b.Write(s.status.AsSlice())
	b.Write(s.records.AsSlice())
	return AccountCellDataV1{inner: b.Bytes()}
}

func (s *AccountCellDataV1Builder) Id(v AccountId) *AccountCellDataV1Builder {
	s.id = v
	return s
}

func (s *AccountCellDataV1Builder) Account(v AccountChars) *AccountCellDataV1Builder {
	s.account = v
	return s
}

func (s *AccountCellDataV1Builder) RegisteredAt(v Uint64) *AccountCellDataV1Builder {
	s.registered_at = v
	return s
}

func (s *AccountCellDataV1Builder) UpdatedAt(v Uint64) *AccountCellDataV1Builder {
	s.updated_at = v
	return s
}

func (s *AccountCellDataV1Builder) Status(v Uint8) *AccountCellDataV1Builder {
	s.status = v
	return s
}

func (s *AccountCellDataV1Builder) Records(v Records) *AccountCellDataV1Builder {
	s.records = v
	return s
}

func NewAccountCellDataV1Builder() *AccountCellDataV1Builder {
	return &AccountCellDataV1Builder{id: AccountIdDefault(), account: AccountCharsDefault(), registered_at: Uint64Default(), updated_at: Uint64Default(), status: Uint8Default(), records: RecordsDefault()}
}

type AccountCellDataV1 struct {
	inner []byte
}

func AccountCellDataV1FromSliceUnchecked(slice []byte) *AccountCellDataV1 {
	return &AccountCellDataV1{inner: slice}
}
func (s *AccountCellDataV1) AsSlice() []byte {
	return s.inner
}

func AccountCellDataV1Default() AccountCellDataV1 {
	return *AccountCellDataV1FromSliceUnchecked([]byte{73, 0, 0, 0, 28, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 68, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func AccountCellDataV1FromSlice(slice []byte, compatible bool) (*AccountCellDataV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &AccountCellDataV1{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellDataV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountCharsFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = RecordsFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountCellDataV1{inner: slice}, nil
}

func (s *AccountCellDataV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountCellDataV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountCellDataV1) Len() uint {
	return s.FieldCount()
}
func (s *AccountCellDataV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountCellDataV1) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *AccountCellDataV1) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *AccountCellDataV1) Id() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV1) Account() *AccountChars {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV1) RegisteredAt() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV1) UpdatedAt() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV1) Status() *Uint8 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV1) Records() *Records {
	var ret *Records
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = RecordsFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = RecordsFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountCellDataV1) AsBuilder() AccountCellDataV1Builder {
	ret := NewAccountCellDataV1Builder().Id(*s.Id()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).UpdatedAt(*s.UpdatedAt()).Status(*s.Status()).Records(*s.Records())
	return *ret
}

type AccountCellDataBuilder struct {
	id                       AccountId
	account                  AccountChars
	registered_at            Uint64
	last_transfer_account_at Timestamp
	last_edit_manager_at     Timestamp
	last_edit_records_at     Timestamp
	status                   Uint8
	records                  Records
}

func (s *AccountCellDataBuilder) Build() AccountCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registered_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_transfer_account_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_edit_manager_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_edit_records_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.records.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.registered_at.AsSlice())
	b.Write(s.last_transfer_account_at.AsSlice())
	b.Write(s.last_edit_manager_at.AsSlice())
	b.Write(s.last_edit_records_at.AsSlice())
	b.Write(s.status.AsSlice())
	b.Write(s.records.AsSlice())
	return AccountCellData{inner: b.Bytes()}
}

func (s *AccountCellDataBuilder) Id(v AccountId) *AccountCellDataBuilder {
	s.id = v
	return s
}

func (s *AccountCellDataBuilder) Account(v AccountChars) *AccountCellDataBuilder {
	s.account = v
	return s
}

func (s *AccountCellDataBuilder) RegisteredAt(v Uint64) *AccountCellDataBuilder {
	s.registered_at = v
	return s
}

func (s *AccountCellDataBuilder) LastTransferAccountAt(v Timestamp) *AccountCellDataBuilder {
	s.last_transfer_account_at = v
	return s
}

func (s *AccountCellDataBuilder) LastEditManagerAt(v Timestamp) *AccountCellDataBuilder {
	s.last_edit_manager_at = v
	return s
}

func (s *AccountCellDataBuilder) LastEditRecordsAt(v Timestamp) *AccountCellDataBuilder {
	s.last_edit_records_at = v
	return s
}

func (s *AccountCellDataBuilder) Status(v Uint8) *AccountCellDataBuilder {
	s.status = v
	return s
}

func (s *AccountCellDataBuilder) Records(v Records) *AccountCellDataBuilder {
	s.records = v
	return s
}

func NewAccountCellDataBuilder() *AccountCellDataBuilder {
	return &AccountCellDataBuilder{id: AccountIdDefault(), account: AccountCharsDefault(), registered_at: Uint64Default(), last_transfer_account_at: TimestampDefault(), last_edit_manager_at: TimestampDefault(), last_edit_records_at: TimestampDefault(), status: Uint8Default(), records: RecordsDefault()}
}

type AccountCellData struct {
	inner []byte
}

func AccountCellDataFromSliceUnchecked(slice []byte) *AccountCellData {
	return &AccountCellData{inner: slice}
}
func (s *AccountCellData) AsSlice() []byte {
	return s.inner
}

func AccountCellDataDefault() AccountCellData {
	return *AccountCellDataFromSliceUnchecked([]byte{97, 0, 0, 0, 36, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 68, 0, 0, 0, 76, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func AccountCellDataFromSlice(slice []byte, compatible bool) (*AccountCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 8 == 0 {
		return &AccountCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountCharsFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountCellData{inner: slice}, nil
}

func (s *AccountCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountCellData) Len() uint {
	return s.FieldCount()
}
func (s *AccountCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountCellData) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *AccountCellData) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *AccountCellData) Id() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Account() *AccountChars {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) RegisteredAt() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) LastTransferAccountAt() *Timestamp {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) LastEditManagerAt() *Timestamp {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) LastEditRecordsAt() *Timestamp {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Status() *Uint8 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Records() *Records {
	var ret *Records
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = RecordsFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = RecordsFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountCellData) AsBuilder() AccountCellDataBuilder {
	ret := NewAccountCellDataBuilder().Id(*s.Id()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).LastTransferAccountAt(*s.LastTransferAccountAt()).LastEditManagerAt(*s.LastEditManagerAt()).LastEditRecordsAt(*s.LastEditRecordsAt()).Status(*s.Status()).Records(*s.Records())
	return *ret
}

type AccountIdBuilder struct {
	inner [20]Byte
}

func NewAccountIdBuilder() *AccountIdBuilder {
	return &AccountIdBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *AccountIdBuilder) Build() AccountId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return AccountId{inner: b.Bytes()}
}

func (s *AccountIdBuilder) Set(v [20]Byte) *AccountIdBuilder {
	s.inner = v
	return s
}

func (s *AccountIdBuilder) Nth0(v Byte) *AccountIdBuilder {
	s.inner[0] = v
	return s
}

func (s *AccountIdBuilder) Nth1(v Byte) *AccountIdBuilder {
	s.inner[1] = v
	return s
}

func (s *AccountIdBuilder) Nth2(v Byte) *AccountIdBuilder {
	s.inner[2] = v
	return s
}

func (s *AccountIdBuilder) Nth3(v Byte) *AccountIdBuilder {
	s.inner[3] = v
	return s
}

func (s *AccountIdBuilder) Nth4(v Byte) *AccountIdBuilder {
	s.inner[4] = v
	return s
}

func (s *AccountIdBuilder) Nth5(v Byte) *AccountIdBuilder {
	s.inner[5] = v
	return s
}

func (s *AccountIdBuilder) Nth6(v Byte) *AccountIdBuilder {
	s.inner[6] = v
	return s
}

func (s *AccountIdBuilder) Nth7(v Byte) *AccountIdBuilder {
	s.inner[7] = v
	return s
}

func (s *AccountIdBuilder) Nth8(v Byte) *AccountIdBuilder {
	s.inner[8] = v
	return s
}

func (s *AccountIdBuilder) Nth9(v Byte) *AccountIdBuilder {
	s.inner[9] = v
	return s
}

func (s *AccountIdBuilder) Nth10(v Byte) *AccountIdBuilder {
	s.inner[10] = v
	return s
}

func (s *AccountIdBuilder) Nth11(v Byte) *AccountIdBuilder {
	s.inner[11] = v
	return s
}

func (s *AccountIdBuilder) Nth12(v Byte) *AccountIdBuilder {
	s.inner[12] = v
	return s
}

func (s *AccountIdBuilder) Nth13(v Byte) *AccountIdBuilder {
	s.inner[13] = v
	return s
}

func (s *AccountIdBuilder) Nth14(v Byte) *AccountIdBuilder {
	s.inner[14] = v
	return s
}

func (s *AccountIdBuilder) Nth15(v Byte) *AccountIdBuilder {
	s.inner[15] = v
	return s
}

func (s *AccountIdBuilder) Nth16(v Byte) *AccountIdBuilder {
	s.inner[16] = v
	return s
}

func (s *AccountIdBuilder) Nth17(v Byte) *AccountIdBuilder {
	s.inner[17] = v
	return s
}

func (s *AccountIdBuilder) Nth18(v Byte) *AccountIdBuilder {
	s.inner[18] = v
	return s
}

func (s *AccountIdBuilder) Nth19(v Byte) *AccountIdBuilder {
	s.inner[19] = v
	return s
}

type AccountId struct {
	inner []byte
}

func AccountIdFromSliceUnchecked(slice []byte) *AccountId {
	return &AccountId{inner: slice}
}
func (s *AccountId) AsSlice() []byte {
	return s.inner
}

func AccountIdDefault() AccountId {
	return *AccountIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountIdFromSlice(slice []byte, _compatible bool) (*AccountId, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &AccountId{inner: slice}, nil
}

func (s *AccountId) RawData() []byte {
	return s.inner
}

func (s *AccountId) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *AccountId) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *AccountId) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *AccountId) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *AccountId) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *AccountId) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *AccountId) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *AccountId) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *AccountId) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *AccountId) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *AccountId) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *AccountId) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *AccountId) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *AccountId) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *AccountId) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *AccountId) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *AccountId) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *AccountId) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *AccountId) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *AccountId) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *AccountId) AsBuilder() AccountIdBuilder {
	t := NewAccountIdBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type RecordBuilder struct {
	record_type  Bytes
	record_key   Bytes
	record_label Bytes
	record_value Bytes
	record_ttl   Uint32
}

func (s *RecordBuilder) Build() Record {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_key.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_label.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_value.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_ttl.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.record_type.AsSlice())
	b.Write(s.record_key.AsSlice())
	b.Write(s.record_label.AsSlice())
	b.Write(s.record_value.AsSlice())
	b.Write(s.record_ttl.AsSlice())
	return Record{inner: b.Bytes()}
}

func (s *RecordBuilder) RecordType(v Bytes) *RecordBuilder {
	s.record_type = v
	return s
}

func (s *RecordBuilder) RecordKey(v Bytes) *RecordBuilder {
	s.record_key = v
	return s
}

func (s *RecordBuilder) RecordLabel(v Bytes) *RecordBuilder {
	s.record_label = v
	return s
}

func (s *RecordBuilder) RecordValue(v Bytes) *RecordBuilder {
	s.record_value = v
	return s
}

func (s *RecordBuilder) RecordTtl(v Uint32) *RecordBuilder {
	s.record_ttl = v
	return s
}

func NewRecordBuilder() *RecordBuilder {
	return &RecordBuilder{record_type: BytesDefault(), record_key: BytesDefault(), record_label: BytesDefault(), record_value: BytesDefault(), record_ttl: Uint32Default()}
}

type Record struct {
	inner []byte
}

func RecordFromSliceUnchecked(slice []byte) *Record {
	return &Record{inner: slice}
}
func (s *Record) AsSlice() []byte {
	return s.inner
}

func RecordDefault() Record {
	return *RecordFromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func RecordFromSlice(slice []byte, compatible bool) (*Record, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &Record{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Record", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &Record{inner: slice}, nil
}

func (s *Record) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Record) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Record) Len() uint {
	return s.FieldCount()
}
func (s *Record) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Record) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *Record) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *Record) RecordType() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordKey() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordLabel() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordValue() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordTtl() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Record) AsBuilder() RecordBuilder {
	ret := NewRecordBuilder().RecordType(*s.RecordType()).RecordKey(*s.RecordKey()).RecordLabel(*s.RecordLabel()).RecordValue(*s.RecordValue()).RecordTtl(*s.RecordTtl())
	return *ret
}

type RecordsBuilder struct {
	inner []Record
}

func (s *RecordsBuilder) Build() Records {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Records{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Records{inner: b.Bytes()}
}

func (s *RecordsBuilder) Set(v []Record) *RecordsBuilder {
	s.inner = v
	return s
}
func (s *RecordsBuilder) Push(v Record) *RecordsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *RecordsBuilder) Extend(iter []Record) *RecordsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewRecordsBuilder() *RecordsBuilder {
	return &RecordsBuilder{[]Record{}}
}

type Records struct {
	inner []byte
}

func RecordsFromSliceUnchecked(slice []byte) *Records {
	return &Records{inner: slice}
}
func (s *Records) AsSlice() []byte {
	return s.inner
}

func RecordsDefault() Records {
	return *RecordsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func RecordsFromSlice(slice []byte, compatible bool) (*Records, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Records{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Records", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Records"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := RecordFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Records{inner: slice}, nil
}

func (s *Records) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Records) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Records) Len() uint {
	return s.ItemCount()
}
func (s *Records) IsEmpty() bool {
	return s.Len() == 0
}

// if *Record is nil, index is out of bounds
func (s *Records) Get(index uint) *Record {
	var b *Record
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = RecordFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = RecordFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Records) AsBuilder() RecordsBuilder {
	size := s.ItemCount()
	t := NewRecordsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type AccountSaleCellDataV1Builder struct {
	account_id  AccountId
	account     Bytes
	price       Uint64
	description Bytes
	started_at  Uint64
}

func (s *AccountSaleCellDataV1Builder) Build() AccountSaleCellDataV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.description.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.started_at.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.description.AsSlice())
	b.Write(s.started_at.AsSlice())
	return AccountSaleCellDataV1{inner: b.Bytes()}
}

func (s *AccountSaleCellDataV1Builder) AccountId(v AccountId) *AccountSaleCellDataV1Builder {
	s.account_id = v
	return s
}

func (s *AccountSaleCellDataV1Builder) Account(v Bytes) *AccountSaleCellDataV1Builder {
	s.account = v
	return s
}

func (s *AccountSaleCellDataV1Builder) Price(v Uint64) *AccountSaleCellDataV1Builder {
	s.price = v
	return s
}

func (s *AccountSaleCellDataV1Builder) Description(v Bytes) *AccountSaleCellDataV1Builder {
	s.description = v
	return s
}

func (s *AccountSaleCellDataV1Builder) StartedAt(v Uint64) *AccountSaleCellDataV1Builder {
	s.started_at = v
	return s
}

func NewAccountSaleCellDataV1Builder() *AccountSaleCellDataV1Builder {
	return &AccountSaleCellDataV1Builder{account_id: AccountIdDefault(), account: BytesDefault(), price: Uint64Default(), description: BytesDefault(), started_at: Uint64Default()}
}

type AccountSaleCellDataV1 struct {
	inner []byte
}

func AccountSaleCellDataV1FromSliceUnchecked(slice []byte) *AccountSaleCellDataV1 {
	return &AccountSaleCellDataV1{inner: slice}
}
func (s *AccountSaleCellDataV1) AsSlice() []byte {
	return s.inner
}

func AccountSaleCellDataV1Default() AccountSaleCellDataV1 {
	return *AccountSaleCellDataV1FromSliceUnchecked([]byte{68, 0, 0, 0, 24, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountSaleCellDataV1FromSlice(slice []byte, compatible bool) (*AccountSaleCellDataV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &AccountSaleCellDataV1{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountSaleCellDataV1{inner: slice}, nil
}

func (s *AccountSaleCellDataV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountSaleCellDataV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountSaleCellDataV1) Len() uint {
	return s.FieldCount()
}
func (s *AccountSaleCellDataV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountSaleCellDataV1) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *AccountSaleCellDataV1) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *AccountSaleCellDataV1) AccountId() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellDataV1) Account() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellDataV1) Price() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellDataV1) Description() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellDataV1) StartedAt() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountSaleCellDataV1) AsBuilder() AccountSaleCellDataV1Builder {
	ret := NewAccountSaleCellDataV1Builder().AccountId(*s.AccountId()).Account(*s.Account()).Price(*s.Price()).Description(*s.Description()).StartedAt(*s.StartedAt())
	return *ret
}

type AccountSaleCellDataBuilder struct {
	account_id                AccountId
	account                   Bytes
	price                     Uint64
	description               Bytes
	started_at                Uint64
	buyer_inviter_profit_rate Uint32
}

func (s *AccountSaleCellDataBuilder) Build() AccountSaleCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.description.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.started_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.buyer_inviter_profit_rate.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.description.AsSlice())
	b.Write(s.started_at.AsSlice())
	b.Write(s.buyer_inviter_profit_rate.AsSlice())
	return AccountSaleCellData{inner: b.Bytes()}
}

func (s *AccountSaleCellDataBuilder) AccountId(v AccountId) *AccountSaleCellDataBuilder {
	s.account_id = v
	return s
}

func (s *AccountSaleCellDataBuilder) Account(v Bytes) *AccountSaleCellDataBuilder {
	s.account = v
	return s
}

func (s *AccountSaleCellDataBuilder) Price(v Uint64) *AccountSaleCellDataBuilder {
	s.price = v
	return s
}

func (s *AccountSaleCellDataBuilder) Description(v Bytes) *AccountSaleCellDataBuilder {
	s.description = v
	return s
}

func (s *AccountSaleCellDataBuilder) StartedAt(v Uint64) *AccountSaleCellDataBuilder {
	s.started_at = v
	return s
}

func (s *AccountSaleCellDataBuilder) BuyerInviterProfitRate(v Uint32) *AccountSaleCellDataBuilder {
	s.buyer_inviter_profit_rate = v
	return s
}

func NewAccountSaleCellDataBuilder() *AccountSaleCellDataBuilder {
	return &AccountSaleCellDataBuilder{account_id: AccountIdDefault(), account: BytesDefault(), price: Uint64Default(), description: BytesDefault(), started_at: Uint64Default(), buyer_inviter_profit_rate: Uint32Default()}
}

type AccountSaleCellData struct {
	inner []byte
}

func AccountSaleCellDataFromSliceUnchecked(slice []byte) *AccountSaleCellData {
	return &AccountSaleCellData{inner: slice}
}
func (s *AccountSaleCellData) AsSlice() []byte {
	return s.inner
}

func AccountSaleCellDataDefault() AccountSaleCellData {
	return *AccountSaleCellDataFromSliceUnchecked([]byte{76, 0, 0, 0, 28, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountSaleCellDataFromSlice(slice []byte, compatible bool) (*AccountSaleCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &AccountSaleCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountSaleCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountSaleCellData{inner: slice}, nil
}

func (s *AccountSaleCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountSaleCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountSaleCellData) Len() uint {
	return s.FieldCount()
}
func (s *AccountSaleCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountSaleCellData) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *AccountSaleCellData) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *AccountSaleCellData) AccountId() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellData) Account() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellData) Price() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellData) Description() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellData) StartedAt() *Uint64 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountSaleCellData) BuyerInviterProfitRate() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountSaleCellData) AsBuilder() AccountSaleCellDataBuilder {
	ret := NewAccountSaleCellDataBuilder().AccountId(*s.AccountId()).Account(*s.Account()).Price(*s.Price()).Description(*s.Description()).StartedAt(*s.StartedAt()).BuyerInviterProfitRate(*s.BuyerInviterProfitRate())
	return *ret
}

type AccountAuctionCellDataBuilder struct {
	account_id              AccountId
	account                 Bytes
	description             Bytes
	opening_price           Uint64
	increment_rate_each_bid Uint32
	started_at              Uint64
	ended_at                Uint64
	current_bidder_lock     Script
	current_bid_price       Uint64
	prev_bidder_profit_rate Uint32
}

func (s *AccountAuctionCellDataBuilder) Build() AccountAuctionCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (10 + 1)
	offsets := make([]uint32, 0, 10)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.description.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.opening_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.increment_rate_each_bid.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.started_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ended_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.current_bidder_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.current_bid_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.prev_bidder_profit_rate.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.description.AsSlice())
	b.Write(s.opening_price.AsSlice())
	b.Write(s.increment_rate_each_bid.AsSlice())
	b.Write(s.started_at.AsSlice())
	b.Write(s.ended_at.AsSlice())
	b.Write(s.current_bidder_lock.AsSlice())
	b.Write(s.current_bid_price.AsSlice())
	b.Write(s.prev_bidder_profit_rate.AsSlice())
	return AccountAuctionCellData{inner: b.Bytes()}
}

func (s *AccountAuctionCellDataBuilder) AccountId(v AccountId) *AccountAuctionCellDataBuilder {
	s.account_id = v
	return s
}

func (s *AccountAuctionCellDataBuilder) Account(v Bytes) *AccountAuctionCellDataBuilder {
	s.account = v
	return s
}

func (s *AccountAuctionCellDataBuilder) Description(v Bytes) *AccountAuctionCellDataBuilder {
	s.description = v
	return s
}

func (s *AccountAuctionCellDataBuilder) OpeningPrice(v Uint64) *AccountAuctionCellDataBuilder {
	s.opening_price = v
	return s
}

func (s *AccountAuctionCellDataBuilder) IncrementRateEachBid(v Uint32) *AccountAuctionCellDataBuilder {
	s.increment_rate_each_bid = v
	return s
}

func (s *AccountAuctionCellDataBuilder) StartedAt(v Uint64) *AccountAuctionCellDataBuilder {
	s.started_at = v
	return s
}

func (s *AccountAuctionCellDataBuilder) EndedAt(v Uint64) *AccountAuctionCellDataBuilder {
	s.ended_at = v
	return s
}

func (s *AccountAuctionCellDataBuilder) CurrentBidderLock(v Script) *AccountAuctionCellDataBuilder {
	s.current_bidder_lock = v
	return s
}

func (s *AccountAuctionCellDataBuilder) CurrentBidPrice(v Uint64) *AccountAuctionCellDataBuilder {
	s.current_bid_price = v
	return s
}

func (s *AccountAuctionCellDataBuilder) PrevBidderProfitRate(v Uint32) *AccountAuctionCellDataBuilder {
	s.prev_bidder_profit_rate = v
	return s
}

func NewAccountAuctionCellDataBuilder() *AccountAuctionCellDataBuilder {
	return &AccountAuctionCellDataBuilder{account_id: AccountIdDefault(), account: BytesDefault(), description: BytesDefault(), opening_price: Uint64Default(), increment_rate_each_bid: Uint32Default(), started_at: Uint64Default(), ended_at: Uint64Default(), current_bidder_lock: ScriptDefault(), current_bid_price: Uint64Default(), prev_bidder_profit_rate: Uint32Default()}
}

type AccountAuctionCellData struct {
	inner []byte
}

func AccountAuctionCellDataFromSliceUnchecked(slice []byte) *AccountAuctionCellData {
	return &AccountAuctionCellData{inner: slice}
}
func (s *AccountAuctionCellData) AsSlice() []byte {
	return s.inner
}

func AccountAuctionCellDataDefault() AccountAuctionCellData {
	return *AccountAuctionCellDataFromSliceUnchecked([]byte{165, 0, 0, 0, 44, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 100, 0, 0, 0, 153, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountAuctionCellDataFromSlice(slice []byte, compatible bool) (*AccountAuctionCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 10 == 0 {
		return &AccountAuctionCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountAuctionCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 10 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 10 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountAuctionCellData{inner: slice}, nil
}

func (s *AccountAuctionCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountAuctionCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountAuctionCellData) Len() uint {
	return s.FieldCount()
}
func (s *AccountAuctionCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountAuctionCellData) CountExtraFields() uint {
	return s.FieldCount() - 10
}

func (s *AccountAuctionCellData) HasExtraFields() bool {
	return 10 != s.FieldCount()
}

func (s *AccountAuctionCellData) AccountId() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) Account() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) Description() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) OpeningPrice() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) IncrementRateEachBid() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) StartedAt() *Uint64 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) EndedAt() *Uint64 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) CurrentBidderLock() *Script {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) CurrentBidPrice() *Uint64 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountAuctionCellData) PrevBidderProfitRate() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[40:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[44:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountAuctionCellData) AsBuilder() AccountAuctionCellDataBuilder {
	ret := NewAccountAuctionCellDataBuilder().AccountId(*s.AccountId()).Account(*s.Account()).Description(*s.Description()).OpeningPrice(*s.OpeningPrice()).IncrementRateEachBid(*s.IncrementRateEachBid()).StartedAt(*s.StartedAt()).EndedAt(*s.EndedAt()).CurrentBidderLock(*s.CurrentBidderLock()).CurrentBidPrice(*s.CurrentBidPrice()).PrevBidderProfitRate(*s.PrevBidderProfitRate())
	return *ret
}

type PreAccountCellDataBuilder struct {
	account          AccountChars
	refund_lock      Script
	owner_lock_args  Bytes
	inviter_id       Bytes
	inviter_lock     ScriptOpt
	channel_lock     ScriptOpt
	price            PriceConfig
	quote            Uint64
	invited_discount Uint32
	created_at       Timestamp
}

func (s *PreAccountCellDataBuilder) Build() PreAccountCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (10 + 1)
	offsets := make([]uint32, 0, 10)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.refund_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner_lock_args.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.quote.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.invited_discount.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.created_at.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account.AsSlice())
	b.Write(s.refund_lock.AsSlice())
	b.Write(s.owner_lock_args.AsSlice())
	b.Write(s.inviter_id.AsSlice())
	b.Write(s.inviter_lock.AsSlice())
	b.Write(s.channel_lock.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.quote.AsSlice())
	b.Write(s.invited_discount.AsSlice())
	b.Write(s.created_at.AsSlice())
	return PreAccountCellData{inner: b.Bytes()}
}

func (s *PreAccountCellDataBuilder) Account(v AccountChars) *PreAccountCellDataBuilder {
	s.account = v
	return s
}

func (s *PreAccountCellDataBuilder) RefundLock(v Script) *PreAccountCellDataBuilder {
	s.refund_lock = v
	return s
}

func (s *PreAccountCellDataBuilder) OwnerLockArgs(v Bytes) *PreAccountCellDataBuilder {
	s.owner_lock_args = v
	return s
}

func (s *PreAccountCellDataBuilder) InviterId(v Bytes) *PreAccountCellDataBuilder {
	s.inviter_id = v
	return s
}

func (s *PreAccountCellDataBuilder) InviterLock(v ScriptOpt) *PreAccountCellDataBuilder {
	s.inviter_lock = v
	return s
}

func (s *PreAccountCellDataBuilder) ChannelLock(v ScriptOpt) *PreAccountCellDataBuilder {
	s.channel_lock = v
	return s
}

func (s *PreAccountCellDataBuilder) Price(v PriceConfig) *PreAccountCellDataBuilder {
	s.price = v
	return s
}

func (s *PreAccountCellDataBuilder) Quote(v Uint64) *PreAccountCellDataBuilder {
	s.quote = v
	return s
}

func (s *PreAccountCellDataBuilder) InvitedDiscount(v Uint32) *PreAccountCellDataBuilder {
	s.invited_discount = v
	return s
}

func (s *PreAccountCellDataBuilder) CreatedAt(v Timestamp) *PreAccountCellDataBuilder {
	s.created_at = v
	return s
}

func NewPreAccountCellDataBuilder() *PreAccountCellDataBuilder {
	return &PreAccountCellDataBuilder{account: AccountCharsDefault(), refund_lock: ScriptDefault(), owner_lock_args: BytesDefault(), inviter_id: BytesDefault(), inviter_lock: ScriptOptDefault(), channel_lock: ScriptOptDefault(), price: PriceConfigDefault(), quote: Uint64Default(), invited_discount: Uint32Default(), created_at: TimestampDefault()}
}

type PreAccountCellData struct {
	inner []byte
}

func PreAccountCellDataFromSliceUnchecked(slice []byte) *PreAccountCellData {
	return &PreAccountCellData{inner: slice}
}
func (s *PreAccountCellData) AsSlice() []byte {
	return s.inner
}

func PreAccountCellDataDefault() PreAccountCellData {
	return *PreAccountCellDataFromSliceUnchecked([]byte{162, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 101, 0, 0, 0, 105, 0, 0, 0, 109, 0, 0, 0, 109, 0, 0, 0, 109, 0, 0, 0, 142, 0, 0, 0, 150, 0, 0, 0, 154, 0, 0, 0, 4, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func PreAccountCellDataFromSlice(slice []byte, compatible bool) (*PreAccountCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 10 == 0 {
		return &PreAccountCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 10 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 10 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptOptFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptOptFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PriceConfigFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	return &PreAccountCellData{inner: slice}, nil
}

func (s *PreAccountCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PreAccountCellData) Len() uint {
	return s.FieldCount()
}
func (s *PreAccountCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PreAccountCellData) CountExtraFields() uint {
	return s.FieldCount() - 10
}

func (s *PreAccountCellData) HasExtraFields() bool {
	return 10 != s.FieldCount()
}

func (s *PreAccountCellData) Account() *AccountChars {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) RefundLock() *Script {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) OwnerLockArgs() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) InviterId() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) InviterLock() *ScriptOpt {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return ScriptOptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) ChannelLock() *ScriptOpt {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return ScriptOptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) Price() *PriceConfig {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return PriceConfigFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) Quote() *Uint64 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) InvitedDiscount() *Uint32 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) CreatedAt() *Timestamp {
	var ret *Timestamp
	start := unpackNumber(s.inner[40:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[44:])
		ret = TimestampFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TimestampFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PreAccountCellData) AsBuilder() PreAccountCellDataBuilder {
	ret := NewPreAccountCellDataBuilder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLockArgs(*s.OwnerLockArgs()).InviterId(*s.InviterId()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt())
	return *ret
}

type AccountCharsBuilder struct {
	inner []AccountChar
}

func (s *AccountCharsBuilder) Build() AccountChars {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return AccountChars{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return AccountChars{inner: b.Bytes()}
}

func (s *AccountCharsBuilder) Set(v []AccountChar) *AccountCharsBuilder {
	s.inner = v
	return s
}
func (s *AccountCharsBuilder) Push(v AccountChar) *AccountCharsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *AccountCharsBuilder) Extend(iter []AccountChar) *AccountCharsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewAccountCharsBuilder() *AccountCharsBuilder {
	return &AccountCharsBuilder{[]AccountChar{}}
}

type AccountChars struct {
	inner []byte
}

func AccountCharsFromSliceUnchecked(slice []byte) *AccountChars {
	return &AccountChars{inner: slice}
}
func (s *AccountChars) AsSlice() []byte {
	return s.inner
}

func AccountCharsDefault() AccountChars {
	return *AccountCharsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func AccountCharsFromSlice(slice []byte, compatible bool) (*AccountChars, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &AccountChars{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := AccountCharFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &AccountChars{inner: slice}, nil
}

func (s *AccountChars) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountChars) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountChars) Len() uint {
	return s.ItemCount()
}
func (s *AccountChars) IsEmpty() bool {
	return s.Len() == 0
}

// if *AccountChar is nil, index is out of bounds
func (s *AccountChars) Get(index uint) *AccountChar {
	var b *AccountChar
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = AccountCharFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = AccountCharFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *AccountChars) AsBuilder() AccountCharsBuilder {
	size := s.ItemCount()
	t := NewAccountCharsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type AccountCharBuilder struct {
	char_set_name Uint32
	bytes         Bytes
}

func (s *AccountCharBuilder) Build() AccountChar {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.char_set_name.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.bytes.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.char_set_name.AsSlice())
	b.Write(s.bytes.AsSlice())
	return AccountChar{inner: b.Bytes()}
}

func (s *AccountCharBuilder) CharSetName(v Uint32) *AccountCharBuilder {
	s.char_set_name = v
	return s
}

func (s *AccountCharBuilder) Bytes(v Bytes) *AccountCharBuilder {
	s.bytes = v
	return s
}

func NewAccountCharBuilder() *AccountCharBuilder {
	return &AccountCharBuilder{char_set_name: Uint32Default(), bytes: BytesDefault()}
}

type AccountChar struct {
	inner []byte
}

func AccountCharFromSliceUnchecked(slice []byte) *AccountChar {
	return &AccountChar{inner: slice}
}
func (s *AccountChar) AsSlice() []byte {
	return s.inner
}

func AccountCharDefault() AccountChar {
	return *AccountCharFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountCharFromSlice(slice []byte, compatible bool) (*AccountChar, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &AccountChar{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChar", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountChar{inner: slice}, nil
}

func (s *AccountChar) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountChar) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountChar) Len() uint {
	return s.FieldCount()
}
func (s *AccountChar) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountChar) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *AccountChar) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *AccountChar) CharSetName() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountChar) Bytes() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountChar) AsBuilder() AccountCharBuilder {
	ret := NewAccountCharBuilder().CharSetName(*s.CharSetName()).Bytes(*s.Bytes())
	return *ret
}

type OfferCellDataBuilder struct {
	account      Bytes
	price        Uint64
	message      Bytes
	inviter_lock Script
	channel_lock Script
}

func (s *OfferCellDataBuilder) Build() OfferCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.message.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel_lock.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.message.AsSlice())
	b.Write(s.inviter_lock.AsSlice())
	b.Write(s.channel_lock.AsSlice())
	return OfferCellData{inner: b.Bytes()}
}

func (s *OfferCellDataBuilder) Account(v Bytes) *OfferCellDataBuilder {
	s.account = v
	return s
}

func (s *OfferCellDataBuilder) Price(v Uint64) *OfferCellDataBuilder {
	s.price = v
	return s
}

func (s *OfferCellDataBuilder) Message(v Bytes) *OfferCellDataBuilder {
	s.message = v
	return s
}

func (s *OfferCellDataBuilder) InviterLock(v Script) *OfferCellDataBuilder {
	s.inviter_lock = v
	return s
}

func (s *OfferCellDataBuilder) ChannelLock(v Script) *OfferCellDataBuilder {
	s.channel_lock = v
	return s
}

func NewOfferCellDataBuilder() *OfferCellDataBuilder {
	return &OfferCellDataBuilder{account: BytesDefault(), price: Uint64Default(), message: BytesDefault(), inviter_lock: ScriptDefault(), channel_lock: ScriptDefault()}
}

type OfferCellData struct {
	inner []byte
}

func OfferCellDataFromSliceUnchecked(slice []byte) *OfferCellData {
	return &OfferCellData{inner: slice}
}
func (s *OfferCellData) AsSlice() []byte {
	return s.inner
}

func OfferCellDataDefault() OfferCellData {
	return *OfferCellDataFromSliceUnchecked([]byte{146, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func OfferCellDataFromSlice(slice []byte, compatible bool) (*OfferCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OfferCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &OfferCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "OfferCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &OfferCellData{inner: slice}, nil
}

func (s *OfferCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *OfferCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *OfferCellData) Len() uint {
	return s.FieldCount()
}
func (s *OfferCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *OfferCellData) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *OfferCellData) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *OfferCellData) Account() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *OfferCellData) Price() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *OfferCellData) Message() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *OfferCellData) InviterLock() *Script {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *OfferCellData) ChannelLock() *Script {
	var ret *Script
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = ScriptFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ScriptFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *OfferCellData) AsBuilder() OfferCellDataBuilder {
	ret := NewOfferCellDataBuilder().Account(*s.Account()).Price(*s.Price()).Message(*s.Message()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock())
	return *ret
}
